{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Range and Launch Angle Introduction In this presentation, we explore how far a projectile travels depending on the angle it is launched. This distance is called the range . We focus on ideal conditions \u2014 no air resistance, starting and landing on the same level. What is a Projectile? A projectile is any object thrown into the air that moves under the force of gravity only (we ignore air resistance here). Examples: A basketball shot A soccer pass A cannonball What is Range? The range is the total horizontal distance the projectile travels across the ground before hitting the ground again . \\[ \\text{Range} = \\text{Horizontal speed} \\times \\text{Time of flight} \\] Horizontal and Vertical Motion Projectile motion has two parts : Horizontal Motion Speed: \\(v_x = v_0 \\cos \\theta\\) No forces act horizontally \u2192 speed stays constant. Vertical Motion Speed: \\(v_y = v_0 \\sin \\theta\\) Gravity acts downward \u2192 object goes up and then comes down. Time of Flight To calculate how long the projectile is in the air: \\[ t = \\frac{2v_0 \\sin \\theta}{g} \\] More upward speed \u2192 longer flight. Symmetrical: same time up and down. Range Formula Start with: $$ R = v_x \\times t = v_0 \\cos \\theta \\times \\frac{2v_0 \\sin \\theta}{g} $$ Now simplify: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Final formula tells us: Range depends on speed squared , Launch angle through \\(\\sin 2\\theta\\) , And gravity . Graph: Range vs. Launch Angle This graph shows how range changes depending on the launch angle: The peak is at 45\u00b0 Range is the same at 30\u00b0 and 60\u00b0 At 0\u00b0 and 90\u00b0 , the range is zero. Key Observations Maximum range at 45\u00b0 \\(\\sin 2\\theta\\) causes symmetry in the graph: \\(\\theta = 30^\\circ\\) and \\(\\theta = 60^\\circ\\) \u2192 same range Range increases with square of speed: Double the speed \u2192 4 times the range Real-World Examples Athletes often aim around 45\u00b0 for maximum throw. Artillery and rockets use this physics in their targeting. In real life, air resistance would reduce the range. Conclusion Range depends on initial speed , launch angle , and gravity . 45\u00b0 is the ideal launch angle for max range (with no air resistance). The formula \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) summarizes everything.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-range-and-launch-angle","text":"","title":"Projectile Range and Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction","text":"In this presentation, we explore how far a projectile travels depending on the angle it is launched. This distance is called the range . We focus on ideal conditions \u2014 no air resistance, starting and landing on the same level.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#what-is-a-projectile","text":"A projectile is any object thrown into the air that moves under the force of gravity only (we ignore air resistance here). Examples: A basketball shot A soccer pass A cannonball","title":"What is a Projectile?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#what-is-range","text":"The range is the total horizontal distance the projectile travels across the ground before hitting the ground again . \\[ \\text{Range} = \\text{Horizontal speed} \\times \\text{Time of flight} \\]","title":"What is Range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-and-vertical-motion","text":"Projectile motion has two parts :","title":"Horizontal and Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Speed: \\(v_x = v_0 \\cos \\theta\\) No forces act horizontally \u2192 speed stays constant.","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Speed: \\(v_y = v_0 \\sin \\theta\\) Gravity acts downward \u2192 object goes up and then comes down.","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"To calculate how long the projectile is in the air: \\[ t = \\frac{2v_0 \\sin \\theta}{g} \\] More upward speed \u2192 longer flight. Symmetrical: same time up and down.","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"Start with: $$ R = v_x \\times t = v_0 \\cos \\theta \\times \\frac{2v_0 \\sin \\theta}{g} $$ Now simplify: \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] Final formula tells us: Range depends on speed squared , Launch angle through \\(\\sin 2\\theta\\) , And gravity .","title":"Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graph-range-vs-launch-angle","text":"This graph shows how range changes depending on the launch angle: The peak is at 45\u00b0 Range is the same at 30\u00b0 and 60\u00b0 At 0\u00b0 and 90\u00b0 , the range is zero.","title":"Graph: Range vs. Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Maximum range at 45\u00b0 \\(\\sin 2\\theta\\) causes symmetry in the graph: \\(\\theta = 30^\\circ\\) and \\(\\theta = 60^\\circ\\) \u2192 same range Range increases with square of speed: Double the speed \u2192 4 times the range","title":"Key Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-examples","text":"Athletes often aim around 45\u00b0 for maximum throw. Artillery and rockets use this physics in their targeting. In real life, air resistance would reduce the range.","title":"Real-World Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Range depends on initial speed , launch angle , and gravity . 45\u00b0 is the ideal launch angle for max range (with no air resistance). The formula \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) summarizes everything.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Introduction The forced damped pendulum is a fundamental system in physics and engineering that demonstrates a transition from simple harmonic motion to resonance and chaos due to the interplay of damping, restoring forces, and external periodic forcing. This study helps us understand complex real-world applications, including energy harvesting, vibration isolation, and mechanical resonance. 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is described by the following differential equation : \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] where: \\(\u03b8\\) \u2192 Angular displacement (radians) \\(b\\) \u2192 Damping coefficient (controls energy loss) \\(g\\) \u2192 Gravitational acceleration \\(L\\) \u2192 Length of the pendulum \\(A\\) \u2192 Amplitude of the external driving force \\(\u03a9\\) \u2192 Frequency of the external force Small-Angle Approximation For small oscillations , we approximate \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear equation , and its solution describes harmonic oscillations . Resonance Conditions When the driving frequency \\(\u03a9\\) matches the system's natural frequency: $$ \\omega_0 = \\sqrt{\\frac{g}{L}} $$ resonance occurs, leading to maximum oscillations . At high amplitudes, the system can enter chaotic motion . 2. Analysis of Dynamics Key Parameters Affecting Motion Damping coefficient \\(b\\) : Higher damping reduces oscillations and suppresses chaos. Driving force amplitude \\(A\\) : Large values introduce nonlinear behavior and chaos. Driving frequency \\(\u03a9\\) : Affects resonance and synchronization. Regular vs. Chaotic Motion Low damping & weak forcing \u2192 Periodic oscillations (predictable motion). Moderate forcing \u2192 Resonance (large oscillations at specific frequencies). High forcing & nonlinearity \u2192 Chaos (unpredictable motion with extreme sensitivity to initial conditions). 3. Real-World Applications Common Uses of Forced Damped Pendulums Suspension Bridges \u2192 Studying oscillations in structures. Energy Harvesting \u2192 Using vibrations to generate electricity. Oscillating Circuits \u2192 Analogous to driven RLC circuits . Real-World Example: A Playground Swing A swing acts as a forced damped pendulum: The child\u2019s motion adds an external periodic force . If pushing is in sync with the swing\u2019s natural frequency \u2192 Resonance occurs (higher amplitude). If air resistance & friction increase \u2192 Damping reduces motion . Random pushing at different times can lead to chaotic motion . 4. Computational Implementation We develop a Python simulation to: Numerically solve the differential equation . Visualize pendulum motion for different damping and forcing. Generate phase diagrams and Poincar\u00e9 sections to illustrate chaotic transitions. Python Script import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.5 # Damping coefficient g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of the pendulum (m) A = 1.2 # Driving force amplitude omega_drive = 2.0 # Driving frequency # Initial conditions theta_0 = 0.2 # Initial angle (radians) omega_0 = 0.0 # Initial angular velocity # Time span t_span = (0, 20) # Simulate for 20 seconds t_eval = np.linspace(*t_span, 1000) # Solve the equation sol = solve_ivp(forced_damped_pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(b, g, L, A, omega_drive)) # Plot results plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], label='Theta (Angular Displacement)', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (radians)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This graph shows how the angular displacement of the pendulum changes over time under damping and periodic forcing. Expected Additional Plots: Phase portraits to visualize stability and chaos. Bifurcation diagrams to show changes in periodicity. Conclusion The forced damped pendulum is a rich model for exploring chaotic dynamics, resonance, and real-world oscillations . By analyzing its behavior, we gain insights into engineering, physics, and even biological rhythms .","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#introduction","text":"The forced damped pendulum is a fundamental system in physics and engineering that demonstrates a transition from simple harmonic motion to resonance and chaos due to the interplay of damping, restoring forces, and external periodic forcing. This study helps us understand complex real-world applications, including energy harvesting, vibration isolation, and mechanical resonance.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is described by the following differential equation : \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] where: \\(\u03b8\\) \u2192 Angular displacement (radians) \\(b\\) \u2192 Damping coefficient (controls energy loss) \\(g\\) \u2192 Gravitational acceleration \\(L\\) \u2192 Length of the pendulum \\(A\\) \u2192 Amplitude of the external driving force \\(\u03a9\\) \u2192 Frequency of the external force","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations , we approximate \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear equation , and its solution describes harmonic oscillations .","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"When the driving frequency \\(\u03a9\\) matches the system's natural frequency: $$ \\omega_0 = \\sqrt{\\frac{g}{L}} $$ resonance occurs, leading to maximum oscillations . At high amplitudes, the system can enter chaotic motion .","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#key-parameters-affecting-motion","text":"Damping coefficient \\(b\\) : Higher damping reduces oscillations and suppresses chaos. Driving force amplitude \\(A\\) : Large values introduce nonlinear behavior and chaos. Driving frequency \\(\u03a9\\) : Affects resonance and synchronization.","title":"Key Parameters Affecting Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"Low damping & weak forcing \u2192 Periodic oscillations (predictable motion). Moderate forcing \u2192 Resonance (large oscillations at specific frequencies). High forcing & nonlinearity \u2192 Chaos (unpredictable motion with extreme sensitivity to initial conditions).","title":"Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"","title":"3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#common-uses-of-forced-damped-pendulums","text":"Suspension Bridges \u2192 Studying oscillations in structures. Energy Harvesting \u2192 Using vibrations to generate electricity. Oscillating Circuits \u2192 Analogous to driven RLC circuits .","title":"Common Uses of Forced Damped Pendulums"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#real-world-example-a-playground-swing","text":"A swing acts as a forced damped pendulum: The child\u2019s motion adds an external periodic force . If pushing is in sync with the swing\u2019s natural frequency \u2192 Resonance occurs (higher amplitude). If air resistance & friction increase \u2192 Damping reduces motion . Random pushing at different times can lead to chaotic motion .","title":"Real-World Example: A Playground Swing"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computational-implementation","text":"We develop a Python simulation to: Numerically solve the differential equation . Visualize pendulum motion for different damping and forcing. Generate phase diagrams and Poincar\u00e9 sections to illustrate chaotic transitions.","title":"4. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-script","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.5 # Damping coefficient g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of the pendulum (m) A = 1.2 # Driving force amplitude omega_drive = 2.0 # Driving frequency # Initial conditions theta_0 = 0.2 # Initial angle (radians) omega_0 = 0.0 # Initial angular velocity # Time span t_span = (0, 20) # Simulate for 20 seconds t_eval = np.linspace(*t_span, 1000) # Solve the equation sol = solve_ivp(forced_damped_pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(b, g, L, A, omega_drive)) # Plot results plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], label='Theta (Angular Displacement)', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (radians)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This graph shows how the angular displacement of the pendulum changes over time under damping and periodic forcing.","title":"Python Script"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#expected-additional-plots","text":"Phase portraits to visualize stability and chaos. Bifurcation diagrams to show changes in periodicity.","title":"Expected Additional Plots:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum is a rich model for exploring chaotic dynamics, resonance, and real-world oscillations . By analyzing its behavior, we gain insights into engineering, physics, and even biological rhythms .","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Radius \"The harmony of the world is made manifest in the laws of nature.\" \u2013 Kepler What Are We Exploring? We aim to understand how a planet or satellite\u2019s orbital period (how long it takes to complete an orbit) is related to its distance from the central body . This brings us to Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\] Where: \\(T\\) = Orbital period \\(r\\) = Orbital radius The Physics Behind It We start from two fundamental physics principles: Newton\u2019s Law of Gravitation: $$ F = \\frac{G M m}{r^2} $$ Centripetal force needed to keep an object in circular motion: $$ F = \\frac{m v^2}{r} $$ Setting them equal, and working through the math (see full derivation in notebook), we arrive at: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] This shows that for circular orbits , the square of the orbital period is proportional to the cube of the radius. Real-World Example: The Moon & Earth By measuring: \\(T\\) (orbital period \u2248 27.3 days) \\(r\\) (distance from Earth to Moon \u2248 384,400 km) we can apply Kepler\u2019s Law to calculate Earth\u2019s mass \u2014 or vice versa , confirm these values based on known mass. Visual Verification We ran a Python simulation to compute and plot \\(T^2\\) and \\(r^3\\) values for circular orbits around Earth. Below is the graph showing this relationship: As expected, the relationship is linear , confirming Kepler's Third Law in action. Why Does This Matter? Helps design satellite orbits (e.g., GPS, Starlink) Enables planetary exploration by predicting orbital paths Essential for calculating masses of planets and stars What About Elliptical Orbits? Kepler\u2019s Law also applies to elliptical orbits , with a small change: \\[ T^2 \\propto a^3 \\] Where \\(a\\) is the semi-major axis of the ellipse. Summary We derived Kepler\u2019s Third Law from basic physics. We verified it through Python simulation. We explored how it's used in astronomy and satellite science.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-radius","text":"\"The harmony of the world is made manifest in the laws of nature.\" \u2013 Kepler","title":"Kepler's Third Law: Orbital Period and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#what-are-we-exploring","text":"We aim to understand how a planet or satellite\u2019s orbital period (how long it takes to complete an orbit) is related to its distance from the central body . This brings us to Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\] Where: \\(T\\) = Orbital period \\(r\\) = Orbital radius","title":"What Are We Exploring?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-physics-behind-it","text":"We start from two fundamental physics principles: Newton\u2019s Law of Gravitation: $$ F = \\frac{G M m}{r^2} $$ Centripetal force needed to keep an object in circular motion: $$ F = \\frac{m v^2}{r} $$ Setting them equal, and working through the math (see full derivation in notebook), we arrive at: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] This shows that for circular orbits , the square of the orbital period is proportional to the cube of the radius.","title":"The Physics Behind It"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-example-the-moon-earth","text":"By measuring: \\(T\\) (orbital period \u2248 27.3 days) \\(r\\) (distance from Earth to Moon \u2248 384,400 km) we can apply Kepler\u2019s Law to calculate Earth\u2019s mass \u2014 or vice versa , confirm these values based on known mass.","title":"Real-World Example: The Moon &amp; Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visual-verification","text":"We ran a Python simulation to compute and plot \\(T^2\\) and \\(r^3\\) values for circular orbits around Earth. Below is the graph showing this relationship: As expected, the relationship is linear , confirming Kepler's Third Law in action.","title":"Visual Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#why-does-this-matter","text":"Helps design satellite orbits (e.g., GPS, Starlink) Enables planetary exploration by predicting orbital paths Essential for calculating masses of planets and stars","title":"Why Does This Matter?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#what-about-elliptical-orbits","text":"Kepler\u2019s Law also applies to elliptical orbits , with a small change: \\[ T^2 \\propto a^3 \\] Where \\(a\\) is the semi-major axis of the ellipse.","title":"What About Elliptical Orbits?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived Kepler\u2019s Third Law from basic physics. We verified it through Python simulation. We explored how it's used in astronomy and satellite science.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities \u201cThe Earth is the cradle of humanity, but one cannot remain in the cradle forever.\u201d \u2013 Konstantin Tsiolkovsky Overview Cosmic velocities define the speeds needed for different types of motion under a planet\u2019s gravitational pull. These thresholds are fundamental to space exploration , from placing satellites in orbit to launching probes into interstellar space. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) The minimum speed required to stay in a stable circular orbit just above a planet\u2019s surface. $$ v_1 = \\sqrt{\\frac{G M}{r}} $$ Second Cosmic Velocity (Escape Velocity) The minimum speed required to completely escape the gravitational field of a planet without further propulsion. $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} $$ Third Cosmic Velocity (Solar Escape Velocity) The speed needed to escape the gravitational pull of the Sun from Earth\u2019s surface. This includes Earth\u2019s orbital motion and the Sun\u2019s gravitational field. Approximate value: $$ v_3 \\approx 42.1 \\text{ km/s (from Earth)} $$ Parameters and Equations To compute these velocities, we use the following parameters: Planet Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.3895 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\) Visual Comparison of Velocities The following chart shows the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. For solar escape (v\u2083), only Earth is shown. Real-World Applications Mission Type Required Velocity Placing a satellite in orbit \\(v_1\\) Sending a spacecraft to the Moon or Mars \\(v_2\\) Voyager, New Horizons, Interstellar missions \\(v_3\\) Applying Cosmic Velocities A rocket launching from Earth must first reach orbital velocity (v\u2081) to stay in space. To break free from Earth\u2019s gravity, it must accelerate to escape velocity (v\u2082) . To leave the Solar System , like the Voyager missions , it must achieve the third cosmic velocity (v\u2083) . Conclusion First cosmic velocity lets you orbit. Second cosmic velocity lets you escape. Third cosmic velocity lets you leave the Solar System. These values are not just theoretical\u2014they define the thresholds every rocket must overcome in real missions.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"\u201cThe Earth is the cradle of humanity, but one cannot remain in the cradle forever.\u201d \u2013 Konstantin Tsiolkovsky","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#overview","text":"Cosmic velocities define the speeds needed for different types of motion under a planet\u2019s gravitational pull. These thresholds are fundamental to space exploration , from placing satellites in orbit to launching probes into interstellar space.","title":"Overview"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The minimum speed required to stay in a stable circular orbit just above a planet\u2019s surface. $$ v_1 = \\sqrt{\\frac{G M}{r}} $$","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The minimum speed required to completely escape the gravitational field of a planet without further propulsion. $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} $$","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-escape-velocity","text":"The speed needed to escape the gravitational pull of the Sun from Earth\u2019s surface. This includes Earth\u2019s orbital motion and the Sun\u2019s gravitational field. Approximate value: $$ v_3 \\approx 42.1 \\text{ km/s (from Earth)} $$","title":"Third Cosmic Velocity (Solar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-and-equations","text":"To compute these velocities, we use the following parameters: Planet Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.3895 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\)","title":"Parameters and Equations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visual-comparison-of-velocities","text":"The following chart shows the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. For solar escape (v\u2083), only Earth is shown.","title":"Visual Comparison of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#real-world-applications","text":"Mission Type Required Velocity Placing a satellite in orbit \\(v_1\\) Sending a spacecraft to the Moon or Mars \\(v_2\\) Voyager, New Horizons, Interstellar missions \\(v_3\\)","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#applying-cosmic-velocities","text":"A rocket launching from Earth must first reach orbital velocity (v\u2081) to stay in space. To break free from Earth\u2019s gravity, it must accelerate to escape velocity (v\u2082) . To leave the Solar System , like the Voyager missions , it must achieve the third cosmic velocity (v\u2083) .","title":"Applying Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"First cosmic velocity lets you orbit. Second cosmic velocity lets you escape. Third cosmic velocity lets you leave the Solar System. These values are not just theoretical\u2014they define the thresholds every rocket must overcome in real missions.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object (payload) is released from a rocket near Earth, it enters a new gravitational context depending on its velocity, position, and direction. This scenario helps us explore the principles of orbital mechanics , gravitational physics , and space mission dynamics . Theoretical Background Newton's Law of Gravitation The force acting on the payload due to Earth's gravity is: $$ \\vec{F} = -\\frac{G M m}{r^2} \\hat{r} $$ Where: - \\(G\\) is the gravitational constant \\(M\\) is Earth\u2019s mass \\(m\\) is the payload\u2019s mass \\(r\\) is the distance from Earth's center \\(\\hat{r}\\) is the unit vector pointing from the payload to the Earth\u2019s center This force produces an acceleration: $$ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} $$ Orbital Energy and Trajectory Types The total mechanical energy \\(E\\) of the payload determines the type of trajectory: - \\(E < 0\\) : Elliptical orbit (bound) \\(E = 0\\) : Parabolic trajectory (escape edge) \\(E > 0\\) : Hyperbolic trajectory (escape) Key Velocities Orbital velocity : \\( \\(v = \\sqrt{\\frac{G M}{r}}\\) \\) Escape velocity : \\( \\(v = \\sqrt{\\frac{2 G M}{r}}\\) \\) Simulation in Python Below is a Python implementation that simulates the motion of a payload released from low Earth orbit with various initial speeds. Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Gravitational acceleration function def gravity(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, vy, ax, ay] # Initial conditions for different velocities altitude = 300e3 # 300 km above Earth surface r0 = R_earth + altitude angles = [0, 30, 45, 60] # degrees # Choose initial speeds v_orbit = np.sqrt(G * M / r0) # orbital v_escape = np.sqrt(2 * G * M / r0) # escape velocities = [0.8 * v_orbit, v_orbit, 1.1 * v_orbit, v_escape * 1.05] # Time span t_span = (0, 7000) t_eval = np.linspace(*t_span, 1000) # Plot setup plt.figure(figsize=(8, 8)) for v0 in velocities: y0 = [r0, 0, 0, v0] # launch from (r0, 0) with velocity in y direction sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) plt.plot(sol.y[0] / 1e3, sol.y[1] / 1e3, label=f'v0 = {v0/1e3:.2f} km/s') # Earth circle = plt.Circle((0, 0), R_earth / 1e3, color='blue', alpha=0.3, label='Earth') plt.gca().add_artist(circle) plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Payload Trajectories from Low Earth Orbit') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Trajectory Types Observed Sub-orbital fall (if initial speed is too low) Circular/Elliptical orbit (if speed \u2248 orbital speed) Escape (if speed > escape velocity) Hyperbolic (if speed greatly exceeds escape velocity) Real-World Applications Satellite deployment : Requires precision in velocity to maintain orbit Reentry capsules : Released to descend back to Earth Interplanetary missions : Require escape trajectory from Earth and then Sun Conclusion By changing the initial speed and angle , the payload\u2019s trajectory dramatically shifts. Numerical simulations provide deep insights into how small changes affect mission success\u2014from stable orbits to deep space escape. This analysis and tool are fundamental in planning any real-world space deployment or return mission.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object (payload) is released from a rocket near Earth, it enters a new gravitational context depending on its velocity, position, and direction. This scenario helps us explore the principles of orbital mechanics , gravitational physics , and space mission dynamics .","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The force acting on the payload due to Earth's gravity is: $$ \\vec{F} = -\\frac{G M m}{r^2} \\hat{r} $$ Where: - \\(G\\) is the gravitational constant \\(M\\) is Earth\u2019s mass \\(m\\) is the payload\u2019s mass \\(r\\) is the distance from Earth's center \\(\\hat{r}\\) is the unit vector pointing from the payload to the Earth\u2019s center This force produces an acceleration: $$ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} $$","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-energy-and-trajectory-types","text":"The total mechanical energy \\(E\\) of the payload determines the type of trajectory: - \\(E < 0\\) : Elliptical orbit (bound) \\(E = 0\\) : Parabolic trajectory (escape edge) \\(E > 0\\) : Hyperbolic trajectory (escape)","title":"Orbital Energy and Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-velocities","text":"Orbital velocity : \\( \\(v = \\sqrt{\\frac{G M}{r}}\\) \\) Escape velocity : \\( \\(v = \\sqrt{\\frac{2 G M}{r}}\\) \\)","title":"Key Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-in-python","text":"Below is a Python implementation that simulates the motion of a payload released from low Earth orbit with various initial speeds.","title":"Simulation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Gravitational acceleration function def gravity(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, vy, ax, ay] # Initial conditions for different velocities altitude = 300e3 # 300 km above Earth surface r0 = R_earth + altitude angles = [0, 30, 45, 60] # degrees # Choose initial speeds v_orbit = np.sqrt(G * M / r0) # orbital v_escape = np.sqrt(2 * G * M / r0) # escape velocities = [0.8 * v_orbit, v_orbit, 1.1 * v_orbit, v_escape * 1.05] # Time span t_span = (0, 7000) t_eval = np.linspace(*t_span, 1000) # Plot setup plt.figure(figsize=(8, 8)) for v0 in velocities: y0 = [r0, 0, 0, v0] # launch from (r0, 0) with velocity in y direction sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) plt.plot(sol.y[0] / 1e3, sol.y[1] / 1e3, label=f'v0 = {v0/1e3:.2f} km/s') # Earth circle = plt.Circle((0, 0), R_earth / 1e3, color='blue', alpha=0.3, label='Earth') plt.gca().add_artist(circle) plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Payload Trajectories from Low Earth Orbit') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types-observed","text":"Sub-orbital fall (if initial speed is too low) Circular/Elliptical orbit (if speed \u2248 orbital speed) Escape (if speed > escape velocity) Hyperbolic (if speed greatly exceeds escape velocity)","title":"Trajectory Types Observed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Satellite deployment : Requires precision in velocity to maintain orbit Reentry capsules : Released to descend back to Earth Interplanetary missions : Require escape trajectory from Earth and then Sun","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"By changing the initial speed and angle , the payload\u2019s trajectory dramatically shifts. Numerical simulations provide deep insights into how small changes affect mission success\u2014from stable orbits to deep space escape. This analysis and tool are fundamental in planning any real-world space deployment or return mission.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Introduction This report focuses on the interference of surface water waves originating from multiple coherent point sources. These sources are placed at the vertices of a regular polygon, ensuring symmetrical spacing and uniform conditions for wave propagation. The primary objective is to analyze how the superposition of such waves forms complex interference patterns, and to understand the role of geometrical arrangements and wave parameters in shaping these patterns. The simulation is developed in Python using numerical techniques and graphical visualization. By plotting the resultant displacement of the water surface, we can clearly distinguish between areas of constructive and destructive interference and study their symmetry. Geometrical Configuration of Sources import matplotlib.pyplot as plt import numpy as np n_sources = 4 radius = 2 angles = np.linspace(0, 2*np.pi, n_sources, endpoint=False) x_coords = radius * np.cos(angles) y_coords = radius * np.sin(angles) fig, ax = plt.subplots(figsize=(6,6)) ax.scatter(x_coords, y_coords, color='red', label='Sources') for i, (x, y) in enumerate(zip(x_coords, y_coords)): ax.text(x + 0.1, y + 0.1, f\"S{i+1}\", fontsize=12) circle = plt.Circle((0, 0), radius, color='blue', fill=False, linestyle='--', alpha=0.5) ax.add_patch(circle) ax.set_xlim(-3, 3) ax.set_ylim(-3, 3) ax.set_aspect('equal') ax.grid(True) ax.legend() plt.title('Wave Sources Positioned on a Square') plt.show() All sources are coherent and monochromatic (same wavelength, frequency, and amplitude). Waves propagate as circular wavefronts from each source. The water surface displacement is calculated using the principle of linear superposition. Simulation is conducted in 2D space on a uniform grid. Mathematical Background The displacement \\(u\\vec{r}\\) , t at position \\(\\vec{r}\\) and time \\(t\\) due to a single wave source at position \\(\\vec{r}_0\\) is given by: \\[u(\\vec{r}, t) = A \\sin(k|\\vec{r} - \\vec{r}_0| - \\omega t + \\phi)\\] Where: - \\(A\\) : Amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number, \\(\\lambda\\) is the wavelength \\(\\omega = 2\\pi f\\) : Angular frequency, \\(f\\) is the frequency \\(\\phi\\) : Initial phase \\(|\\vec{r} - \\vec{r}_0|\\) : Distance from the source to point \\(\\vec{r}\\) The total displacement from multiple sources is: \\[u_{total}(\\vec{r}, t) = \\sum_{i=1}^{N} A \\sin(k|\\vec{r} - \\vec{r}_i| - \\omega t + \\phi)\\] Where \\(N\\) is the number of sources. Implementation in Python Imports import numpy as np import matplotlib.pyplot as plt Parameters A = 1.0 # Amplitude wavelength = 2.0 # Wavelength (lambda) k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0.0 # Initial phase Simulation Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) t = 0 # Time snapshot (can vary this for animation) Polygon Source Placement n_sources = 4 # Change to 3, 5, etc. for other polygons radius = 2.0 # Distance from center to each source angles = np.linspace(0, 2 * np.pi, n_sources, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] Superposition of Waves Z_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z = A * np.sin(k * r - omega * t + phi) Z_total += Z Visualization of Interference Pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Z_total, levels=200, cmap='RdBu') plt.colorbar(label='Displacement') plt.title(f'Interference Pattern from {n_sources}-Sided Polygon Configuration') plt.xlabel('x position') plt.ylabel('y position') plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.5) plt.show() Observations and Analysis The resulting interference pattern, derived from the superposition of waves emitted at regular polygon vertices, reveals several significant physical phenomena: Constructive Interference Constructive interference occurs at points where the wavefronts from multiple sources arrive in phase. This means the path length differences between sources correspond to integer multiples of the wavelength. In the visualization, these points manifest as high-displacement fringes. For a square configuration, these fringes exhibit square symmetry, with pronounced periodicity along diagonals and sides. Destructive Interference Destructive interference emerges where wavefronts arrive out of phase (typically by half a wavelength). This leads to cancellation of displacement, and such areas are represented by low or nearly zero values in the plot. These points often lie between the maxima and form nodal lines or regions, creating the characteristic ripple effects seen in the interference map. Symmetry of the Pattern The symmetry of the polygonal configuration plays a crucial role in shaping the pattern. A square arrangement yields a pattern with fourfold rotational symmetry and reflectional symmetry along its diagonals and axes. If the number of sources changes (e.g., using a triangle or pentagon), the symmetry and spacing of the interference fringes would also change correspondingly. Fringe Spacing and Wavelength Relationship The density of interference fringes is inversely proportional to the wavelength. A shorter wavelength results in more closely spaced fringes, increasing the resolution and complexity of the pattern. In this simulation, the chosen wavelength balances clarity with computational feasibility. Interpretation of the Color Map The color map in the visualization represents instantaneous displacement of the water surface. Red and blue regions denote opposite displacement polarities (peaks and troughs), while intermediate colors indicate zero-crossings or regions of destructive interference. The clear, periodic alternation between high and low displacement illustrates the coherent and stable nature of the wave sources. Influence of Source Radius The radius of the polygon (i.e., the distance from the origin to each source) determines the overall scale of the interference structure. A larger radius spreads the sources farther apart, potentially increasing the central region\u2019s complexity. Conversely, a smaller radius condenses the interference features near the center. Overall, the analysis shows that the resulting interference pattern is a rich function of geometry, wavelength, and wave coherence. These findings are fundamental in fields like optics, acoustics, and fluid dynamics. Animate the wave pattern over time by varying t Use other polygons (triangle, pentagon, hexagon) and compare their patterns Change phase differences between sources for more complex interactions Add damping or nonlinear effects for more realism Conclusion This simulation effectively visualizes how waves from multiple sources interact on a water surface. By leveraging symmetry and wave superposition, we gain a clearer understanding of the principles of interference and the beauty of wave physics in two dimensions.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"This report focuses on the interference of surface water waves originating from multiple coherent point sources. These sources are placed at the vertices of a regular polygon, ensuring symmetrical spacing and uniform conditions for wave propagation. The primary objective is to analyze how the superposition of such waves forms complex interference patterns, and to understand the role of geometrical arrangements and wave parameters in shaping these patterns. The simulation is developed in Python using numerical techniques and graphical visualization. By plotting the resultant displacement of the water surface, we can clearly distinguish between areas of constructive and destructive interference and study their symmetry.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#geometrical-configuration-of-sources","text":"import matplotlib.pyplot as plt import numpy as np n_sources = 4 radius = 2 angles = np.linspace(0, 2*np.pi, n_sources, endpoint=False) x_coords = radius * np.cos(angles) y_coords = radius * np.sin(angles) fig, ax = plt.subplots(figsize=(6,6)) ax.scatter(x_coords, y_coords, color='red', label='Sources') for i, (x, y) in enumerate(zip(x_coords, y_coords)): ax.text(x + 0.1, y + 0.1, f\"S{i+1}\", fontsize=12) circle = plt.Circle((0, 0), radius, color='blue', fill=False, linestyle='--', alpha=0.5) ax.add_patch(circle) ax.set_xlim(-3, 3) ax.set_ylim(-3, 3) ax.set_aspect('equal') ax.grid(True) ax.legend() plt.title('Wave Sources Positioned on a Square') plt.show() All sources are coherent and monochromatic (same wavelength, frequency, and amplitude). Waves propagate as circular wavefronts from each source. The water surface displacement is calculated using the principle of linear superposition. Simulation is conducted in 2D space on a uniform grid.","title":"Geometrical Configuration of Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-background","text":"The displacement \\(u\\vec{r}\\) , t at position \\(\\vec{r}\\) and time \\(t\\) due to a single wave source at position \\(\\vec{r}_0\\) is given by: \\[u(\\vec{r}, t) = A \\sin(k|\\vec{r} - \\vec{r}_0| - \\omega t + \\phi)\\] Where: - \\(A\\) : Amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number, \\(\\lambda\\) is the wavelength \\(\\omega = 2\\pi f\\) : Angular frequency, \\(f\\) is the frequency \\(\\phi\\) : Initial phase \\(|\\vec{r} - \\vec{r}_0|\\) : Distance from the source to point \\(\\vec{r}\\) The total displacement from multiple sources is: \\[u_{total}(\\vec{r}, t) = \\sum_{i=1}^{N} A \\sin(k|\\vec{r} - \\vec{r}_i| - \\omega t + \\phi)\\] Where \\(N\\) is the number of sources.","title":"Mathematical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#implementation-in-python","text":"","title":"Implementation in Python"},{"location":"1%20Physics/3%20Waves/Problem_1/#imports","text":"import numpy as np import matplotlib.pyplot as plt","title":"Imports"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"A = 1.0 # Amplitude wavelength = 2.0 # Wavelength (lambda) k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0.0 # Initial phase","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-grid","text":"x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) t = 0 # Time snapshot (can vary this for animation)","title":"Simulation Grid"},{"location":"1%20Physics/3%20Waves/Problem_1/#polygon-source-placement","text":"n_sources = 4 # Change to 3, 5, etc. for other polygons radius = 2.0 # Distance from center to each source angles = np.linspace(0, 2 * np.pi, n_sources, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles]","title":"Polygon Source Placement"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"Z_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z = A * np.sin(k * r - omega * t + phi) Z_total += Z","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization-of-interference-pattern","text":"plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Z_total, levels=200, cmap='RdBu') plt.colorbar(label='Displacement') plt.title(f'Interference Pattern from {n_sources}-Sided Polygon Configuration') plt.xlabel('x position') plt.ylabel('y position') plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.5) plt.show()","title":"Visualization of Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations-and-analysis","text":"The resulting interference pattern, derived from the superposition of waves emitted at regular polygon vertices, reveals several significant physical phenomena:","title":"Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Constructive interference occurs at points where the wavefronts from multiple sources arrive in phase. This means the path length differences between sources correspond to integer multiples of the wavelength. In the visualization, these points manifest as high-displacement fringes. For a square configuration, these fringes exhibit square symmetry, with pronounced periodicity along diagonals and sides.","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Destructive interference emerges where wavefronts arrive out of phase (typically by half a wavelength). This leads to cancellation of displacement, and such areas are represented by low or nearly zero values in the plot. These points often lie between the maxima and form nodal lines or regions, creating the characteristic ripple effects seen in the interference map.","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-of-the-pattern","text":"The symmetry of the polygonal configuration plays a crucial role in shaping the pattern. A square arrangement yields a pattern with fourfold rotational symmetry and reflectional symmetry along its diagonals and axes. If the number of sources changes (e.g., using a triangle or pentagon), the symmetry and spacing of the interference fringes would also change correspondingly.","title":"Symmetry of the Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#fringe-spacing-and-wavelength-relationship","text":"The density of interference fringes is inversely proportional to the wavelength. A shorter wavelength results in more closely spaced fringes, increasing the resolution and complexity of the pattern. In this simulation, the chosen wavelength balances clarity with computational feasibility.","title":"Fringe Spacing and Wavelength Relationship"},{"location":"1%20Physics/3%20Waves/Problem_1/#interpretation-of-the-color-map","text":"The color map in the visualization represents instantaneous displacement of the water surface. Red and blue regions denote opposite displacement polarities (peaks and troughs), while intermediate colors indicate zero-crossings or regions of destructive interference. The clear, periodic alternation between high and low displacement illustrates the coherent and stable nature of the wave sources.","title":"Interpretation of the Color Map"},{"location":"1%20Physics/3%20Waves/Problem_1/#influence-of-source-radius","text":"The radius of the polygon (i.e., the distance from the origin to each source) determines the overall scale of the interference structure. A larger radius spreads the sources farther apart, potentially increasing the central region\u2019s complexity. Conversely, a smaller radius condenses the interference features near the center. Overall, the analysis shows that the resulting interference pattern is a rich function of geometry, wavelength, and wave coherence. These findings are fundamental in fields like optics, acoustics, and fluid dynamics. Animate the wave pattern over time by varying t Use other polygons (triangle, pentagon, hexagon) and compare their patterns Change phase differences between sources for more complex interactions Add damping or nonlinear effects for more realism","title":"Influence of Source Radius"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation effectively visualizes how waves from multiple sources interact on a water surface. By leveraging symmetry and wave superposition, we gain a clearer understanding of the principles of interference and the beauty of wave physics in two dimensions.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Lorentz Force Simulation: Motion of Charged Particles in Electric and Magnetic Fields Introduction The Lorentz force is the fundamental expression governing how charged particles move under the influence of electric and magnetic fields. It is given by: \\[\\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B})\\] Where: \\(q\\) is the charge of the particle \\(\\vec{E}\\) is the electric field vector \\(\\vec{B}\\) is the magnetic field vector \\(\\vec{v}\\) is the velocity vector of the particle This simulation demonstrates how particle motion is affected in different field configurations using numerical integration methods. Applications of the Lorentz Force Cyclotrons and Synchrotrons : Particle accelerators use magnetic fields to bend and focus beams of charged particles. Mass Spectrometry : Ions are separated based on their mass-to-charge ratio using magnetic and electric fields. Plasma Confinement : Magnetic fields are used to trap and control high-temperature plasmas in fusion devices (e.g., tokamaks). Electric fields accelerate charged particles, while magnetic fields bend their paths, causing circular or helical motion depending on the velocity vector. Complete Python Implementation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Physical constants q = 1.6e-19 # Charge (Coulombs) m = 1.67e-27 # Mass (kg) - using proton for better numerical stability # Mass (kg) # Choose one of the following cases: # Case 1: Uniform magnetic field only E = np.array([0.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) # Case 2: Crossed electric and magnetic fields (E \u22a5 B) # E = np.array([0.0, 100.0, 0.0]) # B = np.array([0.0, 0.0, 1.0]) # Case 3: Parallel E and B fields # E = np.array([0.0, 0.0, 100.0]) # B = np.array([0.0, 0.0, 1.0]) # Case 4: Only electric field (electric field acceleration) # E = np.array([100.0, 0.0, 0.0]) # B = np.array([0.0, 0.0, 0.0]) # Initial velocity and position v0 = np.array([1e5, 0.0, 0.0]) # Velocity in m/s r0 = np.array([0.0, 0.0, 0.0]) # Start at origin dt = 1e-10 steps = 3000 # Lorentz force equation def lorentz_force(q, E, B, v): return q * (E + np.cross(v, B)) # Motion simulation using Euler method def simulate_motion(q, m, E, B, r0, v0, dt, steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, steps): F = lorentz_force(q, E, B, v[i-1]) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r, v # Run the simulation r, v = simulate_motion(q, m, E, B, r0, v0, dt, steps) # Combined 2D Trajectories in One Plot # Define field configurations to test (E, B, label, color) cases = [ (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'Magnetic Field Only', 'blue'), (np.array([0.0, 100.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'E \u22a5 B Drift', 'green'), (np.array([0.0, 0.0, 100.0]), np.array([0.0, 0.0, 1.0]), 'E \u2016 B Fields', 'orange'), (np.array([100.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]), 'Electric Field Only', 'red'), (np.array([50.0, 50.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'Oblique E Field', 'purple'), (np.array([0.0, 0.0, 0.0]), np.array([1.0, 1.0, 1.0]), 'Diagonal B Field', 'brown') ] plt.figure(figsize=(10, 8)) for E_test, B_test, label, color in cases: r_case, _ = simulate_motion(q, m, E_test, B_test, r0, v0, dt, steps) plt.plot(r_case[:, 0], r_case[:, 1], label=label, color=color) plt.xlabel('X (m)') plt.ylabel('Y (m)') plt.title('Combined Trajectories in XY Plane') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Analysis The motion of a charged particle under the influence of electric and magnetic fields can vary significantly depending on the field configuration and the particle's initial velocity. This section breaks down key physical interpretations of the simulated motion, with accompanying visual examples to aid comprehension. 1. Uniform Magnetic Field (E = 0, B \u2260 0) In this configuration, the particle experiences a centripetal Lorentz force perpendicular to both its velocity and the magnetic field. If the initial velocity is perpendicular to the magnetic field, the result is circular motion . If the initial velocity has components both perpendicular and parallel to the field, the particle follows a helical path . plt.figure(figsize=(6,6)) plt.plot(r[:,0], r[:,1]) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Top View: Circular/Helical Motion in Uniform Magnetic Field') plt.axis('equal') plt.grid(True) plt.show() 2. Crossed Electric and Magnetic Fields (E \u22a5 B) When both E and B fields are present and perpendicular to each other, the charged particle undergoes a drift motion . The net motion combines the cyclotron motion with a linear drift in the direction of E \u00d7 B. This is known as the E \u00d7 B drift . Drift velocity: v_d = (E \u00d7 B) / B\u00b2 Simulation parameters for \\(E \u00d7 B\\) drift: E = np.array([0, 1e3, 0]) B = np.array([0, 0, 1]) Expected result: a helical trajectory drifting in the x-direction. 3. Larmor Radius (Cyclotron Radius) The Larmor radius, or gyroradius, defines the radius of circular motion in a magnetic field: \\[r_L = (m * v_perp) / (q * B)\\] It depends on the particle\u2019s mass, charge, magnetic field strength, and the perpendicular velocity component. A larger mass or velocity leads to a wider spiral. 4. Energy Conservation In a uniform magnetic field, the force is always perpendicular to the velocity, meaning the magnetic force does no work. Therefore, the kinetic energy of the particle remains constant throughout the motion. 5. Practical Example: Cyclotron A cyclotron accelerates particles using a combination of electric fields (for acceleration) and magnetic fields (to bend the path into circles). The simulation mimics the forces acting on particles in such devices, illustrating circular or helical motion\u2014fundamental to understanding particle dynamics in accelerators.","title":"Lorentz Force Simulation: Motion of Charged Particles in Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation-motion-of-charged-particles-in-electric-and-magnetic-fields","text":"","title":"Lorentz Force Simulation: Motion of Charged Particles in Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force is the fundamental expression governing how charged particles move under the influence of electric and magnetic fields. It is given by: \\[\\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B})\\] Where: \\(q\\) is the charge of the particle \\(\\vec{E}\\) is the electric field vector \\(\\vec{B}\\) is the magnetic field vector \\(\\vec{v}\\) is the velocity vector of the particle This simulation demonstrates how particle motion is affected in different field configurations using numerical integration methods.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"Cyclotrons and Synchrotrons : Particle accelerators use magnetic fields to bend and focus beams of charged particles. Mass Spectrometry : Ions are separated based on their mass-to-charge ratio using magnetic and electric fields. Plasma Confinement : Magnetic fields are used to trap and control high-temperature plasmas in fusion devices (e.g., tokamaks). Electric fields accelerate charged particles, while magnetic fields bend their paths, causing circular or helical motion depending on the velocity vector.","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#complete-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Physical constants q = 1.6e-19 # Charge (Coulombs) m = 1.67e-27 # Mass (kg) - using proton for better numerical stability # Mass (kg) # Choose one of the following cases: # Case 1: Uniform magnetic field only E = np.array([0.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) # Case 2: Crossed electric and magnetic fields (E \u22a5 B) # E = np.array([0.0, 100.0, 0.0]) # B = np.array([0.0, 0.0, 1.0]) # Case 3: Parallel E and B fields # E = np.array([0.0, 0.0, 100.0]) # B = np.array([0.0, 0.0, 1.0]) # Case 4: Only electric field (electric field acceleration) # E = np.array([100.0, 0.0, 0.0]) # B = np.array([0.0, 0.0, 0.0]) # Initial velocity and position v0 = np.array([1e5, 0.0, 0.0]) # Velocity in m/s r0 = np.array([0.0, 0.0, 0.0]) # Start at origin dt = 1e-10 steps = 3000 # Lorentz force equation def lorentz_force(q, E, B, v): return q * (E + np.cross(v, B)) # Motion simulation using Euler method def simulate_motion(q, m, E, B, r0, v0, dt, steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, steps): F = lorentz_force(q, E, B, v[i-1]) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r, v # Run the simulation r, v = simulate_motion(q, m, E, B, r0, v0, dt, steps) # Combined 2D Trajectories in One Plot # Define field configurations to test (E, B, label, color) cases = [ (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'Magnetic Field Only', 'blue'), (np.array([0.0, 100.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'E \u22a5 B Drift', 'green'), (np.array([0.0, 0.0, 100.0]), np.array([0.0, 0.0, 1.0]), 'E \u2016 B Fields', 'orange'), (np.array([100.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]), 'Electric Field Only', 'red'), (np.array([50.0, 50.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'Oblique E Field', 'purple'), (np.array([0.0, 0.0, 0.0]), np.array([1.0, 1.0, 1.0]), 'Diagonal B Field', 'brown') ] plt.figure(figsize=(10, 8)) for E_test, B_test, label, color in cases: r_case, _ = simulate_motion(q, m, E_test, B_test, r0, v0, dt, steps) plt.plot(r_case[:, 0], r_case[:, 1], label=label, color=color) plt.xlabel('X (m)') plt.ylabel('Y (m)') plt.title('Combined Trajectories in XY Plane') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Complete Python Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#analysis","text":"The motion of a charged particle under the influence of electric and magnetic fields can vary significantly depending on the field configuration and the particle's initial velocity. This section breaks down key physical interpretations of the simulated motion, with accompanying visual examples to aid comprehension.","title":"Analysis"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-uniform-magnetic-field-e-0-b-0","text":"In this configuration, the particle experiences a centripetal Lorentz force perpendicular to both its velocity and the magnetic field. If the initial velocity is perpendicular to the magnetic field, the result is circular motion . If the initial velocity has components both perpendicular and parallel to the field, the particle follows a helical path . plt.figure(figsize=(6,6)) plt.plot(r[:,0], r[:,1]) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Top View: Circular/Helical Motion in Uniform Magnetic Field') plt.axis('equal') plt.grid(True) plt.show()","title":"1. Uniform Magnetic Field (E = 0, B \u2260 0)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-crossed-electric-and-magnetic-fields-e-b","text":"When both E and B fields are present and perpendicular to each other, the charged particle undergoes a drift motion . The net motion combines the cyclotron motion with a linear drift in the direction of E \u00d7 B. This is known as the E \u00d7 B drift . Drift velocity: v_d = (E \u00d7 B) / B\u00b2 Simulation parameters for \\(E \u00d7 B\\) drift: E = np.array([0, 1e3, 0]) B = np.array([0, 0, 1]) Expected result: a helical trajectory drifting in the x-direction.","title":"2. Crossed Electric and Magnetic Fields (E \u22a5 B)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-larmor-radius-cyclotron-radius","text":"The Larmor radius, or gyroradius, defines the radius of circular motion in a magnetic field: \\[r_L = (m * v_perp) / (q * B)\\] It depends on the particle\u2019s mass, charge, magnetic field strength, and the perpendicular velocity component. A larger mass or velocity leads to a wider spiral.","title":"3. Larmor Radius (Cyclotron Radius)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-energy-conservation","text":"In a uniform magnetic field, the force is always perpendicular to the velocity, meaning the magnetic force does no work. Therefore, the kinetic energy of the particle remains constant throughout the motion.","title":"4. Energy Conservation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-practical-example-cyclotron","text":"A cyclotron accelerates particles using a combination of electric fields (for acceleration) and magnetic fields (to bend the path into circles). The simulation mimics the forces acting on particles in such devices, illustrating circular or helical motion\u2014fundamental to understanding particle dynamics in accelerators.","title":"5. Practical Example: Cyclotron"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Introduction Determining the equivalent resistance between two points in a circuit is essential for understanding current flow and power distribution. While traditional series-parallel simplifications work for small circuits, complex or nested resistor networks are better handled using graph theory. By modeling the circuit as a graph: Nodes represent electrical junctions. Edges represent resistors with weights equal to their resistance. Problem Setup Graph Representation of a Circuit Each junction in the circuit becomes a node. Each resistor becomes a weighted edge. The goal is to reduce the graph until only one edge remains between the source and target nodes. Pseudocode and Algorithm Description Series Reduction Rule If a node has exactly two neighbors (degree 2) and is not the source/target: Replace it with a direct connection between its neighbors. Combine resistances by addition. Parallel Reduction Rule If there are multiple edges between the same two nodes: Combine resistances using the formula: \\( \\(R_{eq} = ( \\sum_{i} \\frac{1}{R_i})^{-1}\\) \\) Pseudocode FUNCTION simplify_circuit(graph): WHILE graph is not fully reduced: FOR each node: IF degree == 2 and not terminal: replace with series resistor FOR node pairs with multiple edges: replace with single parallel resistor RETURN resistance between source and target Python Implementation Imports and Utilities import networkx as nx import matplotlib.pyplot as plt def combine_series(R1, R2): return R1 + R2 def combine_parallel(R1, R2): return 1 / (1 / R1 + 1 / R2) Visualization Function def draw_graph(G, title): pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=600) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(title) plt.show() Simplification Algorithm def simplify_circuit(G, source, target): step = 1 draw_graph(G, f\"Step {step}: Initial Circuit\") step += 1 changed = True while changed: changed = False for node in list(G.nodes): if node not in [source, target] and G.degree(node) == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and not G.has_edge(neighbors[0], neighbors[1]): r1 = G[neighbors[0]][node]['resistance'] r2 = G[neighbors[1]][node]['resistance'] combined = combine_series(r1, r2) G.add_edge(neighbors[0], neighbors[1], resistance=combined) G.remove_node(node) changed = True draw_graph(G, f\"Step {step}: After series simplification at {node}\") step += 1 break edge_counts = {} for u, v in list(G.edges): key = tuple(sorted([u, v])) edge_counts.setdefault(key, []).append(G[u][v]['resistance']) for (u, v), resistances in edge_counts.items(): if len(resistances) > 1: req = resistances[0] for r in resistances[1:]: req = combine_parallel(req, r) G.remove_edges_from([(u, v)] * len(resistances)) G.add_edge(u, v, resistance=req) changed = True draw_graph(G, f\"Step {step}: After parallel simplification between {u}-{v}\") step += 1 break return G Test Circuit Example G = nx.Graph() G.add_edge('A', 'B', resistance=10) G.add_edge('B', 'C', resistance=20) G.add_edge('A', 'C', resistance=30) simplified = simplify_circuit(G, 'A', 'C') print(\"Final Equivalent Resistance between A and C:\", simplified['A']['C']['resistance']) Analysis and Use Cases Works well for resistive-only circuits. Scales better than manual methods for medium-complexity problems. Can be adapted for educational circuit solvers, PCB validation tools, and simulation engines.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Determining the equivalent resistance between two points in a circuit is essential for understanding current flow and power distribution. While traditional series-parallel simplifications work for small circuits, complex or nested resistor networks are better handled using graph theory. By modeling the circuit as a graph: Nodes represent electrical junctions. Edges represent resistors with weights equal to their resistance.","title":"Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-setup","text":"","title":"Problem Setup"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation-of-a-circuit","text":"Each junction in the circuit becomes a node. Each resistor becomes a weighted edge. The goal is to reduce the graph until only one edge remains between the source and target nodes.","title":"Graph Representation of a Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode-and-algorithm-description","text":"","title":"Pseudocode and Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-reduction-rule","text":"If a node has exactly two neighbors (degree 2) and is not the source/target: Replace it with a direct connection between its neighbors. Combine resistances by addition.","title":"Series Reduction Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-reduction-rule","text":"If there are multiple edges between the same two nodes: Combine resistances using the formula: \\( \\(R_{eq} = ( \\sum_{i} \\frac{1}{R_i})^{-1}\\) \\)","title":"Parallel Reduction Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"FUNCTION simplify_circuit(graph): WHILE graph is not fully reduced: FOR each node: IF degree == 2 and not terminal: replace with series resistor FOR node pairs with multiple edges: replace with single parallel resistor RETURN resistance between source and target","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#imports-and-utilities","text":"import networkx as nx import matplotlib.pyplot as plt def combine_series(R1, R2): return R1 + R2 def combine_parallel(R1, R2): return 1 / (1 / R1 + 1 / R2)","title":"Imports and Utilities"},{"location":"1%20Physics/5%20Circuits/Problem_1/#visualization-function","text":"def draw_graph(G, title): pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=600) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(title) plt.show()","title":"Visualization Function"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simplification-algorithm","text":"def simplify_circuit(G, source, target): step = 1 draw_graph(G, f\"Step {step}: Initial Circuit\") step += 1 changed = True while changed: changed = False for node in list(G.nodes): if node not in [source, target] and G.degree(node) == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and not G.has_edge(neighbors[0], neighbors[1]): r1 = G[neighbors[0]][node]['resistance'] r2 = G[neighbors[1]][node]['resistance'] combined = combine_series(r1, r2) G.add_edge(neighbors[0], neighbors[1], resistance=combined) G.remove_node(node) changed = True draw_graph(G, f\"Step {step}: After series simplification at {node}\") step += 1 break edge_counts = {} for u, v in list(G.edges): key = tuple(sorted([u, v])) edge_counts.setdefault(key, []).append(G[u][v]['resistance']) for (u, v), resistances in edge_counts.items(): if len(resistances) > 1: req = resistances[0] for r in resistances[1:]: req = combine_parallel(req, r) G.remove_edges_from([(u, v)] * len(resistances)) G.add_edge(u, v, resistance=req) changed = True draw_graph(G, f\"Step {step}: After parallel simplification between {u}-{v}\") step += 1 break return G","title":"Simplification Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#test-circuit-example","text":"G = nx.Graph() G.add_edge('A', 'B', resistance=10) G.add_edge('B', 'C', resistance=20) G.add_edge('A', 'C', resistance=30) simplified = simplify_circuit(G, 'A', 'C') print(\"Final Equivalent Resistance between A and C:\", simplified['A']['C']['resistance'])","title":"Test Circuit Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#analysis-and-use-cases","text":"Works well for resistive-only circuits. Scales better than manual methods for medium-complexity problems. Can be adapted for educational circuit solvers, PCB validation tools, and simulation engines.","title":"Analysis and Use Cases"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is a foundational principle in probability and statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases, regardless of the original population distribution \u2014provided the samples are independent and identically distributed. This property is essential for statistical inference and underpins many techniques in hypothesis testing, confidence intervals, and quality control. In this project, we explore the CLT through hands-on simulations using Python. Mathematical Expression of the CLT Let \\(X_1, X_2, \\ldots, X_n\\) be a random sample of size \\(n\\) drawn from a population with: Mean \\(\\mu\\) Standard deviation \\(\\sigma\\) Then the sampling distribution of the sample mean \\(\\bar{X}\\) approaches a normal distribution as \\(n \\to \\infty\\) : \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\xrightarrow{d} \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] This means: The mean of the sampling distribution is \\(\\mu\\) The variance is \\(\\frac{\\sigma^2}{n}\\) The standard deviation (called the standard error) is \\(\\frac{\\sigma}{\\sqrt{n}}\\) Simulation Setup We investigate the CLT using the following population distributions: Uniform Distribution : All values within a range are equally likely. Exponential Distribution : A skewed distribution modeling time between events. Binomial Distribution : Discrete distribution representing success/failure outcomes. Libraries and Configuration import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Plot styling sns.set(style=\"whitegrid\") np.random.seed(42) # Configuration population_size = 100_000 sample_sizes = [5, 10, 30, 50] num_samples = 1000 Uniform Distribution Population Overview # Generate uniform distribution uniform_population = np.random.uniform(low=0, high=10, size=population_size) # Plot population sns.histplot(uniform_population, bins=50, kde=True) plt.title(\"Uniform Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show() Sampling Distributions for n in sample_sizes: means = [np.mean(np.random.choice(uniform_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Uniform, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show() Exponential Distribution Population Overview # Generate exponential distribution exponential_population = np.random.exponential(scale=1.0, size=population_size) sns.histplot(exponential_population, bins=50, kde=True) plt.title(\"Exponential Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show() Sampling Distributions for n in sample_sizes: means = [np.mean(np.random.choice(exponential_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Exponential, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show() Binomial Distribution Population Overview # Generate binomial distribution binomial_population = np.random.binomial(n=10, p=0.5, size=population_size) sns.histplot(binomial_population, bins=11) plt.title(\"Binomial Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show() Sampling Distributions for n in sample_sizes: means = [np.mean(np.random.choice(binomial_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Binomial, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show() Observations As the sample size increases , the sampling distribution of the mean approaches a normal shape . This convergence occurs regardless of the population distribution : For skewed distributions like exponential, larger sample sizes are needed. For symmetric distributions like uniform or binomial, convergence is faster. The spread (standard deviation) of the sampling distribution decreases with larger samples . Real-World Applications The CLT is used in: Estimating population parameters when the population distribution is unknown. Quality control in industrial settings using sample-based inspections. Finance for modeling average returns and risks. Scientific research where sample statistics are used for inference. Tools and Technologies NumPy : Random data generation and statistical operations Matplotlib & Seaborn : Plotting and visualization Conclusion Through these simulations, we observed the Central Limit Theorem in action: no matter the shape of the original distribution, the distribution of the sample mean becomes approximately normal as the sample size increases. This powerful result explains the ubiquity of the normal distribution in statistics and confirms why the CLT is a cornerstone of inferential techniques.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a foundational principle in probability and statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases, regardless of the original population distribution \u2014provided the samples are independent and identically distributed. This property is essential for statistical inference and underpins many techniques in hypothesis testing, confidence intervals, and quality control. In this project, we explore the CLT through hands-on simulations using Python.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#mathematical-expression-of-the-clt","text":"Let \\(X_1, X_2, \\ldots, X_n\\) be a random sample of size \\(n\\) drawn from a population with: Mean \\(\\mu\\) Standard deviation \\(\\sigma\\) Then the sampling distribution of the sample mean \\(\\bar{X}\\) approaches a normal distribution as \\(n \\to \\infty\\) : \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\xrightarrow{d} \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] This means: The mean of the sampling distribution is \\(\\mu\\) The variance is \\(\\frac{\\sigma^2}{n}\\) The standard deviation (called the standard error) is \\(\\frac{\\sigma}{\\sqrt{n}}\\)","title":"Mathematical Expression of the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-setup","text":"We investigate the CLT using the following population distributions: Uniform Distribution : All values within a range are equally likely. Exponential Distribution : A skewed distribution modeling time between events. Binomial Distribution : Discrete distribution representing success/failure outcomes.","title":"Simulation Setup"},{"location":"1%20Physics/6%20Statistics/Problem_1/#libraries-and-configuration","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Plot styling sns.set(style=\"whitegrid\") np.random.seed(42) # Configuration population_size = 100_000 sample_sizes = [5, 10, 30, 50] num_samples = 1000","title":"Libraries and Configuration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#uniform-distribution","text":"","title":"Uniform Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-overview","text":"# Generate uniform distribution uniform_population = np.random.uniform(low=0, high=10, size=population_size) # Plot population sns.histplot(uniform_population, bins=50, kde=True) plt.title(\"Uniform Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show()","title":"Population Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-distributions","text":"for n in sample_sizes: means = [np.mean(np.random.choice(uniform_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Uniform, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show()","title":"Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exponential-distribution","text":"","title":"Exponential Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-overview_1","text":"# Generate exponential distribution exponential_population = np.random.exponential(scale=1.0, size=population_size) sns.histplot(exponential_population, bins=50, kde=True) plt.title(\"Exponential Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show()","title":"Population Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-distributions_1","text":"for n in sample_sizes: means = [np.mean(np.random.choice(exponential_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Exponential, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show()","title":"Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#binomial-distribution","text":"","title":"Binomial Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-overview_2","text":"# Generate binomial distribution binomial_population = np.random.binomial(n=10, p=0.5, size=population_size) sns.histplot(binomial_population, bins=11) plt.title(\"Binomial Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show()","title":"Population Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-distributions_2","text":"for n in sample_sizes: means = [np.mean(np.random.choice(binomial_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Binomial, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show()","title":"Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations","text":"As the sample size increases , the sampling distribution of the mean approaches a normal shape . This convergence occurs regardless of the population distribution : For skewed distributions like exponential, larger sample sizes are needed. For symmetric distributions like uniform or binomial, convergence is faster. The spread (standard deviation) of the sampling distribution decreases with larger samples .","title":"Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-applications","text":"The CLT is used in: Estimating population parameters when the population distribution is unknown. Quality control in industrial settings using sample-based inspections. Finance for modeling average returns and risks. Scientific research where sample statistics are used for inference.","title":"Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#tools-and-technologies","text":"NumPy : Random data generation and statistical operations Matplotlib & Seaborn : Plotting and visualization","title":"Tools and Technologies"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"Through these simulations, we observed the Central Limit Theorem in action: no matter the shape of the original distribution, the distribution of the sample mean becomes approximately normal as the sample size increases. This powerful result explains the ubiquity of the normal distribution in statistics and confirms why the CLT is a cornerstone of inferential techniques.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating Pi using Monte Carlo Methods Motivation Monte Carlo simulations are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. One of the most intuitive applications of this method is estimating the value of \u03c0 using geometric probability. This project demonstrates two powerful Monte Carlo approaches: Using random points inside a square that bounds a unit circle. Simulating Buffon's Needle problem\u2014a famous probability experiment. PART 1: Estimating \u03c0 Using a Circle Theoretical Foundation We consider a unit circle (radius = 1) inscribed in a square of side length 2 (centered at origin). The area of: the circle \\(= \u03c0\u00b7r\u00b2 = \u03c0 (since r = 1)\\) the square \\(= (2\u00b7r)\u00b2 = 4\\) The ratio of their areas is: \\[ \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] If we randomly generate points in the square, the probability that a point falls inside the circle is also \\(\\frac{\\pi}{4}\\) Hence: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Number of points inside the circle}}{\\text{Total number of points}} \\] Python Simulation import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points return pi_estimate, x, y, inside_circle # Example pi, x, y, inside = estimate_pi_circle(10000) print(\"Estimated \u03c0:\", pi) Estimated \u03c0: 3.1336 Visualization plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, color='blue', label='Inside Circle') plt.scatter(x[~inside], y[~inside], s=1, color='red', label='Outside Circle') plt.gca().set_aspect('equal') plt.title('Monte Carlo Estimation of \u03c0') plt.legend() plt.show() Convergence Analysis You can observe convergence by plotting estimated \\(\u03c0\\) values as a function of sample size: samples = [100, 500, 1000, 5000, 10000, 50000] estimates = [estimate_pi_circle(n)[0] for n in samples] plt.plot(samples, estimates, marker='o') plt.axhline(np.pi, color='green', linestyle='--', label='Actual \u03c0') plt.title('Convergence of \u03c0 Estimate') plt.xlabel('Number of Points') plt.ylabel('Estimated \u03c0') plt.legend() plt.grid(True) plt.show() PART 2: Estimating \u03c0 Using Buffon\u2019s Needle Theoretical Foundation Buffon\u2019s Needle problem involves dropping a needle of length \\(L\\) onto a plane with parallel lines a distance \\(D\\) apart (where \\(L \\leq D\\) ). If \\(N\\) needles are dropped and \\(H\\) of them cross a line, then: \\[ \\pi \\approx \\frac{2L \\cdot N}{H \\cdot D} \\] This estimate depends on: Random needle center positions Random needle angles Python Simulation def estimate_pi_buffon(num_needles, L=1.0, D=2.0): if L > D: raise ValueError(\"Needle length must be <= distance between lines.\") # Generate random angles and distances to nearest line theta = np.random.uniform(0, np.pi / 2, num_needles) y = np.random.uniform(0, D / 2, num_needles) crosses = y <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) if num_crosses == 0: return None # Avoid division by zero pi_estimate = (2 * L * num_needles) / (num_crosses * D) return pi_estimate, theta, y, crosses # Example pi_buffon, theta, y_vals, hits = estimate_pi_buffon(10000) print(\"Estimated \u03c0 using Buffon's Needle:\", pi_buffon) Estimated \u03c0 using Buffon's Needle: 3.244646333549643 Visualization plt.figure(figsize=(6, 4)) plt.scatter(theta[hits], y_vals[hits], color='blue', s=5, label='Crossed Line') plt.scatter(theta[~hits], y_vals[~hits], color='red', s=5, label='Did Not Cross') plt.title(\"Buffon's Needle Simulation\") plt.xlabel(\"Angle (\u03b8)\") plt.ylabel(\"Distance to Nearest Line\") plt.legend() plt.grid(True) plt.show() Comparison and Analysis Method Estimate (10K samples) Convergence Rate Notes Circle-based ~3.14 Fast Simple geometry, fast to run Buffon\u2019s Needle ~3.14 (can vary more) Slower Sensitive to randomness Circle method converges more quickly and stably. Buffon\u2019s method gives an elegant probabilistic interpretation of \u03c0. Deliverables Markdown document (this file) explaining the theory and showing code. Python code for both simulations. Plots for circle and needle simulations. Analysis showing convergence and comparing methods. Tools Used NumPy \u2013 random sampling and math Matplotlib \u2013 plotting Jupyter Notebook (recommended for running interactively) Conclusion Monte Carlo methods provide a beautiful, visual, and practical way to understand \u03c0 through randomness and geometry. While both methods are educational, the circle-based method is more computationally efficient and demonstrates fast convergence, whereas Buffon\u2019s Needle showcases the elegance of probability theory in estimating a fundamental constant.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"","title":"Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. One of the most intuitive applications of this method is estimating the value of \u03c0 using geometric probability. This project demonstrates two powerful Monte Carlo approaches: Using random points inside a square that bounds a unit circle. Simulating Buffon's Needle problem\u2014a famous probability experiment.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"PART 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"We consider a unit circle (radius = 1) inscribed in a square of side length 2 (centered at origin). The area of: the circle \\(= \u03c0\u00b7r\u00b2 = \u03c0 (since r = 1)\\) the square \\(= (2\u00b7r)\u00b2 = 4\\) The ratio of their areas is: \\[ \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] If we randomly generate points in the square, the probability that a point falls inside the circle is also \\(\\frac{\\pi}{4}\\) Hence: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Number of points inside the circle}}{\\text{Total number of points}} \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points return pi_estimate, x, y, inside_circle # Example pi, x, y, inside = estimate_pi_circle(10000) print(\"Estimated \u03c0:\", pi) Estimated \u03c0: 3.1336","title":"Python Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization","text":"plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, color='blue', label='Inside Circle') plt.scatter(x[~inside], y[~inside], s=1, color='red', label='Outside Circle') plt.gca().set_aspect('equal') plt.title('Monte Carlo Estimation of \u03c0') plt.legend() plt.show()","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"You can observe convergence by plotting estimated \\(\u03c0\\) values as a function of sample size: samples = [100, 500, 1000, 5000, 10000, 50000] estimates = [estimate_pi_circle(n)[0] for n in samples] plt.plot(samples, estimates, marker='o') plt.axhline(np.pi, color='green', linestyle='--', label='Actual \u03c0') plt.title('Convergence of \u03c0 Estimate') plt.xlabel('Number of Points') plt.ylabel('Estimated \u03c0') plt.legend() plt.grid(True) plt.show()","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"PART 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon\u2019s Needle problem involves dropping a needle of length \\(L\\) onto a plane with parallel lines a distance \\(D\\) apart (where \\(L \\leq D\\) ). If \\(N\\) needles are dropped and \\(H\\) of them cross a line, then: \\[ \\pi \\approx \\frac{2L \\cdot N}{H \\cdot D} \\] This estimate depends on: Random needle center positions Random needle angles","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-simulation_1","text":"def estimate_pi_buffon(num_needles, L=1.0, D=2.0): if L > D: raise ValueError(\"Needle length must be <= distance between lines.\") # Generate random angles and distances to nearest line theta = np.random.uniform(0, np.pi / 2, num_needles) y = np.random.uniform(0, D / 2, num_needles) crosses = y <= (L / 2) * np.sin(theta) num_crosses = np.sum(crosses) if num_crosses == 0: return None # Avoid division by zero pi_estimate = (2 * L * num_needles) / (num_crosses * D) return pi_estimate, theta, y, crosses # Example pi_buffon, theta, y_vals, hits = estimate_pi_buffon(10000) print(\"Estimated \u03c0 using Buffon's Needle:\", pi_buffon) Estimated \u03c0 using Buffon's Needle: 3.244646333549643","title":"Python Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization_1","text":"plt.figure(figsize=(6, 4)) plt.scatter(theta[hits], y_vals[hits], color='blue', s=5, label='Crossed Line') plt.scatter(theta[~hits], y_vals[~hits], color='red', s=5, label='Did Not Cross') plt.title(\"Buffon's Needle Simulation\") plt.xlabel(\"Angle (\u03b8)\") plt.ylabel(\"Distance to Nearest Line\") plt.legend() plt.grid(True) plt.show()","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-and-analysis","text":"Method Estimate (10K samples) Convergence Rate Notes Circle-based ~3.14 Fast Simple geometry, fast to run Buffon\u2019s Needle ~3.14 (can vary more) Slower Sensitive to randomness Circle method converges more quickly and stably. Buffon\u2019s method gives an elegant probabilistic interpretation of \u03c0.","title":"Comparison and Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"Markdown document (this file) explaining the theory and showing code. Python code for both simulations. Plots for circle and needle simulations. Analysis showing convergence and comparing methods.","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/#tools-used","text":"NumPy \u2013 random sampling and math Matplotlib \u2013 plotting Jupyter Notebook (recommended for running interactively)","title":"Tools Used"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Monte Carlo methods provide a beautiful, visual, and practical way to understand \u03c0 through randomness and geometry. While both methods are educational, the circle-based method is more computationally efficient and demonstrates fast convergence, whereas Buffon\u2019s Needle showcases the elegance of probability theory in estimating a fundamental constant.","title":"Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity \\(g\\) is a crucial physical constant influencing various phenomena from falling objects to satellite orbits. A classic method for estimating \\(g\\) is using a simple pendulum , where the period of oscillation is directly related to the length of the pendulum and the local gravitational acceleration. This experiment focuses on: Careful measurement of pendulum parameters Statistical analysis of repeated trials Propagation of uncertainties Materials A string (1.00\u20131.50 meters) A small mass (e.g., keychain, bag of coins) Stopwatch or smartphone timer Ruler or measuring tape (resolution: \u00b10.5 cm or \u00b10.01 m) Setup Attach the mass to the string and suspend it from a fixed point. Measure the length \\(L\\) of the pendulum (from the suspension point to the center of the mass). Example: \\( \\(L = 1.00 \\pm 0.01 \\text{ m}\\) \\) The uncertainty in length \\(\\delta L\\) is half the resolution of your ruler. Data Collection Displace the pendulum by \\(<15\u00b0\\) and release it. Measure the time for 10 complete oscillations , and repeat this 10 times : Example Table Trial Time for 10 Oscillations (s) 1 20.3 2 20.2 3 20.4 4 20.1 5 20.3 6 20.3 7 20.2 8 20.4 9 20.3 10 20.2 Statistical Analysis Mean time for 10 oscillations: \\[ \\bar{t}_{10} = \\frac{\\sum t_i}{10} = 20.27 \\text{ s} \\] Standard deviation: \\[ s = \\sqrt{\\frac{1}{n - 1} \\sum (t_i - \\bar{t})^2} \\approx 0.1 \\text{ s} \\] Uncertainty in the mean time: \\[ \\delta \\bar{t}_{10} = \\frac{s}{\\sqrt{n}} = \\frac{0.1}{\\sqrt{10}} \\approx 0.03 \\text{ s} \\] Calculations 1. Period of one oscillation: \\[ T = \\frac{\\bar{t}_{10}}{10} = 2.027 \\text{ s} \\] \\[ \\delta T = \\frac{\\delta \\bar{t}_{10}}{10} = 0.003 \\text{ s} \\] 2. Calculate \\(g\\) : \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\Rightarrow g = \\frac{4\\pi^2 L}{T^2} \\] \\[ g = \\frac{4\\pi^2 \\cdot 1.00}{(2.027)^2} \\approx 9.59 \\text{ m/s}^2 \\] Uncertainty in \\(g\\) Use propagation of uncertainty: \\[ \\frac{\\delta g}{g} = \\sqrt{\\left(\\frac{\\delta L}{L}\\right)^2 + \\left(2 \\cdot \\frac{\\delta T}{T}\\right)^2} \\] \\[ \\frac{\\delta g}{g} = \\sqrt{\\left(\\frac{0.01}{1.00}\\right)^2 + \\left(2 \\cdot \\frac{0.003}{2.027}\\right)^2} \\approx 0.010 \\] \\[ \\delta g = 9.59 \\cdot 0.010 = 0.10 \\text{ m/s}^2 \\] Final Result \\[ \\boxed{g = 9.59 \\pm 0.10 \\text{ m/s}^2} \\] Analysis 1. Comparison with standard value: Standard gravitational acceleration: \\(9.81 \\text{ m/s}^2\\) Measured value: \\(9.59 \\pm 0.10 \\text{ m/s}^2\\) Slight deviation can be attributed to timing uncertainties, air resistance, and string stiffness. 2. Discussion of Uncertainties: Length uncertainty : From resolution of measuring tape. Timing uncertainty : Due to human reaction time (~0.1 s typical). Experimental conditions : Small angle approximation must be valid; avoid large swings. Python Implementation and Output Analysis import numpy as np # Data: 10 measurements for 10 oscillations times_10_oscillations = np.array([20.3, 20.2, 20.4, 20.1, 20.3, 20.3, 20.2, 20.4, 20.3, 20.2]) # Step 1: Compute statistics mean_t10 = np.mean(times_10_oscillations) sd_t10 = np.std(times_10_oscillations, ddof=1) uncertainty_mean_t10 = sd_t10 / np.sqrt(len(times_10_oscillations)) # Step 2: Period and uncertainty T = mean_t10 / 10 delta_T = uncertainty_mean_t10 / 10 # Step 3: Gravity calculation L = 1.00 # meters delta_L = 0.01 # Gravitational acceleration g = (4 * np.pi**2 * L) / T**2 # Uncertainty in g using propagation formula delta_g_over_g = np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) delta_g = g * delta_g_over_g # Final result print(f\"Mean time for 10 oscillations: {mean_t10:.2f} s\") print(f\"Standard deviation: {sd_t10:.2f} s\") print(f\"Period (T): {T:.4f} s\") print(f\"g = {g:.2f} \u00b1 {delta_g:.2f} m/s\u00b2\") \ud83e\uddfe Sample Output: Mean time for 10 oscillations: 20.27 s Standard deviation: 0.10 s Period (T): 2.0270 s g = 9.59 \u00b1 0.10 m/s\u00b2 import numpy as np import matplotlib.pyplot as plt # Sample data times_10_oscillations = np.array([20.3, 20.2, 20.4, 20.1, 20.3, 20.3, 20.2, 20.4, 20.3, 20.2]) # Calculate period for each trial periods = times_10_oscillations / 10 # Calculate g for each trial L = 1.00 # pendulum length in meters g_values = (4 * np.pi**2 * L) / (periods**2) # Plotting plt.figure(figsize=(8, 5)) plt.plot(range(1, 11), g_values, marker='o', linestyle='-', label='Estimated $g$') plt.axhline(9.81, color='green', linestyle='--', label='Standard $g = 9.81$ m/s\u00b2') plt.title(\"Gravitational Acceleration Estimates from Pendulum Trials\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Estimated $g$ (m/s\u00b2)\") plt.ylim(9.4, 9.9) plt.grid(True) plt.legend() plt.tight_layout() plt.show() Deliverables Tabulated trial data Calculated mean, standard deviation, and uncertainties Final value for \\(g\\) with uncertainty Discussion of sources of error Conclusion By measuring the period of a simple pendulum and analyzing uncertainties rigorously, we estimated \\(g\\) with good accuracy. This classical experiment remains an excellent example of experimental physics in action.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity \\(g\\) is a crucial physical constant influencing various phenomena from falling objects to satellite orbits. A classic method for estimating \\(g\\) is using a simple pendulum , where the period of oscillation is directly related to the length of the pendulum and the local gravitational acceleration. This experiment focuses on: Careful measurement of pendulum parameters Statistical analysis of repeated trials Propagation of uncertainties","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"A string (1.00\u20131.50 meters) A small mass (e.g., keychain, bag of coins) Stopwatch or smartphone timer Ruler or measuring tape (resolution: \u00b10.5 cm or \u00b10.01 m)","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#setup","text":"Attach the mass to the string and suspend it from a fixed point. Measure the length \\(L\\) of the pendulum (from the suspension point to the center of the mass). Example: \\( \\(L = 1.00 \\pm 0.01 \\text{ m}\\) \\) The uncertainty in length \\(\\delta L\\) is half the resolution of your ruler.","title":"Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Displace the pendulum by \\(<15\u00b0\\) and release it. Measure the time for 10 complete oscillations , and repeat this 10 times :","title":"Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#example-table","text":"Trial Time for 10 Oscillations (s) 1 20.3 2 20.2 3 20.4 4 20.1 5 20.3 6 20.3 7 20.2 8 20.4 9 20.3 10 20.2","title":"Example Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#statistical-analysis","text":"","title":"Statistical Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#mean-time-for-10-oscillations","text":"\\[ \\bar{t}_{10} = \\frac{\\sum t_i}{10} = 20.27 \\text{ s} \\]","title":"Mean time for 10 oscillations:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#standard-deviation","text":"\\[ s = \\sqrt{\\frac{1}{n - 1} \\sum (t_i - \\bar{t})^2} \\approx 0.1 \\text{ s} \\]","title":"Standard deviation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-the-mean-time","text":"\\[ \\delta \\bar{t}_{10} = \\frac{s}{\\sqrt{n}} = \\frac{0.1}{\\sqrt{10}} \\approx 0.03 \\text{ s} \\]","title":"Uncertainty in the mean time:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-period-of-one-oscillation","text":"\\[ T = \\frac{\\bar{t}_{10}}{10} = 2.027 \\text{ s} \\] \\[ \\delta T = \\frac{\\delta \\bar{t}_{10}}{10} = 0.003 \\text{ s} \\]","title":"1. Period of one oscillation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-calculate-g","text":"\\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\Rightarrow g = \\frac{4\\pi^2 L}{T^2} \\] \\[ g = \\frac{4\\pi^2 \\cdot 1.00}{(2.027)^2} \\approx 9.59 \\text{ m/s}^2 \\]","title":"2. Calculate \\(g\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"Use propagation of uncertainty: \\[ \\frac{\\delta g}{g} = \\sqrt{\\left(\\frac{\\delta L}{L}\\right)^2 + \\left(2 \\cdot \\frac{\\delta T}{T}\\right)^2} \\] \\[ \\frac{\\delta g}{g} = \\sqrt{\\left(\\frac{0.01}{1.00}\\right)^2 + \\left(2 \\cdot \\frac{0.003}{2.027}\\right)^2} \\approx 0.010 \\] \\[ \\delta g = 9.59 \\cdot 0.010 = 0.10 \\text{ m/s}^2 \\]","title":"Uncertainty in \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result","text":"\\[ \\boxed{g = 9.59 \\pm 0.10 \\text{ m/s}^2} \\]","title":"Final Result"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison-with-standard-value","text":"Standard gravitational acceleration: \\(9.81 \\text{ m/s}^2\\) Measured value: \\(9.59 \\pm 0.10 \\text{ m/s}^2\\) Slight deviation can be attributed to timing uncertainties, air resistance, and string stiffness.","title":"1. Comparison with standard value:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-discussion-of-uncertainties","text":"Length uncertainty : From resolution of measuring tape. Timing uncertainty : Due to human reaction time (~0.1 s typical). Experimental conditions : Small angle approximation must be valid; avoid large swings.","title":"2. Discussion of Uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-implementation-and-output-analysis","text":"import numpy as np # Data: 10 measurements for 10 oscillations times_10_oscillations = np.array([20.3, 20.2, 20.4, 20.1, 20.3, 20.3, 20.2, 20.4, 20.3, 20.2]) # Step 1: Compute statistics mean_t10 = np.mean(times_10_oscillations) sd_t10 = np.std(times_10_oscillations, ddof=1) uncertainty_mean_t10 = sd_t10 / np.sqrt(len(times_10_oscillations)) # Step 2: Period and uncertainty T = mean_t10 / 10 delta_T = uncertainty_mean_t10 / 10 # Step 3: Gravity calculation L = 1.00 # meters delta_L = 0.01 # Gravitational acceleration g = (4 * np.pi**2 * L) / T**2 # Uncertainty in g using propagation formula delta_g_over_g = np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) delta_g = g * delta_g_over_g # Final result print(f\"Mean time for 10 oscillations: {mean_t10:.2f} s\") print(f\"Standard deviation: {sd_t10:.2f} s\") print(f\"Period (T): {T:.4f} s\") print(f\"g = {g:.2f} \u00b1 {delta_g:.2f} m/s\u00b2\")","title":"Python Implementation and Output Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#sample-output","text":"Mean time for 10 oscillations: 20.27 s Standard deviation: 0.10 s Period (T): 2.0270 s g = 9.59 \u00b1 0.10 m/s\u00b2 import numpy as np import matplotlib.pyplot as plt # Sample data times_10_oscillations = np.array([20.3, 20.2, 20.4, 20.1, 20.3, 20.3, 20.2, 20.4, 20.3, 20.2]) # Calculate period for each trial periods = times_10_oscillations / 10 # Calculate g for each trial L = 1.00 # pendulum length in meters g_values = (4 * np.pi**2 * L) / (periods**2) # Plotting plt.figure(figsize=(8, 5)) plt.plot(range(1, 11), g_values, marker='o', linestyle='-', label='Estimated $g$') plt.axhline(9.81, color='green', linestyle='--', label='Standard $g = 9.81$ m/s\u00b2') plt.title(\"Gravitational Acceleration Estimates from Pendulum Trials\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Estimated $g$ (m/s\u00b2)\") plt.ylim(9.4, 9.9) plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83e\uddfe Sample Output:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"Tabulated trial data Calculated mean, standard deviation, and uncertainties Final value for \\(g\\) with uncertainty Discussion of sources of error","title":"Deliverables"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"By measuring the period of a simple pendulum and analyzing uncertainties rigorously, we estimated \\(g\\) with good accuracy. This classical experiment remains an excellent example of experimental physics in action.","title":"Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}