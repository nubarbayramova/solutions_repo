{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Introduction Projectile motion is a fundamental concept in mechanics. In this problem, we analyze how the range of a projectile depends on the angle of projection . Governing Equation The range \\(R\\) of a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\u03b8\\) (with respect to the horizontal) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\(v_0\\) is the initial velocity (m/s), \\(\u03b8\\) is the launch angle (degrees), \\(g\\) is the acceleration due to gravity (m/s\u00b2). Python Implementation import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, g=9.81): \"\"\" Computes the range of a projectile given initial velocity and launch angle. :param v0: Initial velocity (m/s) :param theta: Launch angle (degrees) :param g: Acceleration due to gravity (m/s^2), default is Earth's gravity :return: Range of the projectile (meters) \"\"\" theta_rad = np.radians(theta) # Convert angle to radians return (v0**2 * np.sin(2 * theta_rad)) / g # Simulation parameters angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees initial_velocities = [10, 20, 30] # Different initial velocities g = 9.81 # Gravity (m/s^2) # Plot range vs. angle for different velocities plt.figure(figsize=(8, 6)) for v0 in initial_velocities: ranges = [projectile_range(v0, theta, g) for theta in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range as a Function of Launch Angle') plt.legend() plt.grid() plt.show() Observations The maximum range occurs at 45\u00b0 . The same range is achieved for two complementary angles (e.g., \\(30\u00b0\\) and \\(60\u00b0\\) ). Increasing initial velocity increases the range. Increasing gravity decreases the range. Real-World Applications Projectile motion isn't just theoretical\u2014we experience it in our daily lives: Sports: Kicking a football, throwing a javelin Engineering: Launching rockets or artillery Science: Simulating motion on Earth, Moon, or Mars Kicking a Football Projectile motion is commonly observed in sports, especially football. When a player kicks the ball at an angle, it follows a parabolic trajectory due to gravity\u2014just like the theoretical models we study. Key Insights from This Example: The football behaves like a projectile, launched with an initial velocity and angle. The range of the kick depends on the angle of projection, just like in our model. A kick at around 45\u00b0 will typically result in the maximum horizontal distance . This concept helps athletes and coaches improve technique and optimize performance. Further Exploration Future studies and simulations could consider: Air Resistance: The influence of drag on real-world motion. Uneven Terrain: Effects of launching from different heights. Gravity Variations: Comparing motion on the Moon, Earth, and Mars .","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction","text":"Projectile motion is a fundamental concept in mechanics. In this problem, we analyze how the range of a projectile depends on the angle of projection .","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equation","text":"The range \\(R\\) of a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\u03b8\\) (with respect to the horizontal) is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: \\(v_0\\) is the initial velocity (m/s), \\(\u03b8\\) is the launch angle (degrees), \\(g\\) is the acceleration due to gravity (m/s\u00b2).","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, g=9.81): \"\"\" Computes the range of a projectile given initial velocity and launch angle. :param v0: Initial velocity (m/s) :param theta: Launch angle (degrees) :param g: Acceleration due to gravity (m/s^2), default is Earth's gravity :return: Range of the projectile (meters) \"\"\" theta_rad = np.radians(theta) # Convert angle to radians return (v0**2 * np.sin(2 * theta_rad)) / g # Simulation parameters angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees initial_velocities = [10, 20, 30] # Different initial velocities g = 9.81 # Gravity (m/s^2) # Plot range vs. angle for different velocities plt.figure(figsize=(8, 6)) for v0 in initial_velocities: ranges = [projectile_range(v0, theta, g) for theta in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range as a Function of Launch Angle') plt.legend() plt.grid() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"The maximum range occurs at 45\u00b0 . The same range is achieved for two complementary angles (e.g., \\(30\u00b0\\) and \\(60\u00b0\\) ). Increasing initial velocity increases the range. Increasing gravity decreases the range.","title":"Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-applications","text":"Projectile motion isn't just theoretical\u2014we experience it in our daily lives: Sports: Kicking a football, throwing a javelin Engineering: Launching rockets or artillery Science: Simulating motion on Earth, Moon, or Mars","title":"Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#kicking-a-football","text":"Projectile motion is commonly observed in sports, especially football. When a player kicks the ball at an angle, it follows a parabolic trajectory due to gravity\u2014just like the theoretical models we study.","title":"Kicking a Football"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-insights-from-this-example","text":"The football behaves like a projectile, launched with an initial velocity and angle. The range of the kick depends on the angle of projection, just like in our model. A kick at around 45\u00b0 will typically result in the maximum horizontal distance . This concept helps athletes and coaches improve technique and optimize performance.","title":"Key Insights from This Example:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#further-exploration","text":"Future studies and simulations could consider: Air Resistance: The influence of drag on real-world motion. Uneven Terrain: Effects of launching from different heights. Gravity Variations: Comparing motion on the Moon, Earth, and Mars .","title":"Further Exploration"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Introduction The forced damped pendulum is a fundamental system in physics and engineering that demonstrates a transition from simple harmonic motion to resonance and chaos due to the interplay of damping, restoring forces, and external periodic forcing. This study helps us understand complex real-world applications, including energy harvesting, vibration isolation, and mechanical resonance. 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is described by the following differential equation : \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] where: \\(\u03b8\\) \u2192 Angular displacement (radians) \\(b\\) \u2192 Damping coefficient (controls energy loss) \\(g\\) \u2192 Gravitational acceleration \\(L\\) \u2192 Length of the pendulum \\(A\\) \u2192 Amplitude of the external driving force \\(\u03a9\\) \u2192 Frequency of the external force Small-Angle Approximation For small oscillations , we approximate \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear equation , and its solution describes harmonic oscillations . Resonance Conditions When the driving frequency \\(\u03a9\\) matches the system's natural frequency: $$ \\omega_0 = \\sqrt{\\frac{g}{L}} $$ resonance occurs, leading to maximum oscillations . At high amplitudes, the system can enter chaotic motion . 2. Analysis of Dynamics Key Parameters Affecting Motion Damping coefficient \\(b\\) : Higher damping reduces oscillations and suppresses chaos. Driving force amplitude \\(A\\) : Large values introduce nonlinear behavior and chaos. Driving frequency \\(\u03a9\\) : Affects resonance and synchronization. Regular vs. Chaotic Motion Low damping & weak forcing \u2192 Periodic oscillations (predictable motion). Moderate forcing \u2192 Resonance (large oscillations at specific frequencies). High forcing & nonlinearity \u2192 Chaos (unpredictable motion with extreme sensitivity to initial conditions). 3. Real-World Applications Common Uses of Forced Damped Pendulums Suspension Bridges \u2192 Studying oscillations in structures. Energy Harvesting \u2192 Using vibrations to generate electricity. Oscillating Circuits \u2192 Analogous to driven RLC circuits . Real-World Example: A Playground Swing A swing acts as a forced damped pendulum: The child\u2019s motion adds an external periodic force . If pushing is in sync with the swing\u2019s natural frequency \u2192 Resonance occurs (higher amplitude). If air resistance & friction increase \u2192 Damping reduces motion . Random pushing at different times can lead to chaotic motion . 4. Computational Implementation We develop a Python simulation to: Numerically solve the differential equation . Visualize pendulum motion for different damping and forcing. Generate phase diagrams and Poincar\u00e9 sections to illustrate chaotic transitions. Python Script import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.5 # Damping coefficient g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of the pendulum (m) A = 1.2 # Driving force amplitude omega_drive = 2.0 # Driving frequency # Initial conditions theta_0 = 0.2 # Initial angle (radians) omega_0 = 0.0 # Initial angular velocity # Time span t_span = (0, 20) # Simulate for 20 seconds t_eval = np.linspace(*t_span, 1000) # Solve the equation sol = solve_ivp(forced_damped_pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(b, g, L, A, omega_drive)) # Plot results plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], label='Theta (Angular Displacement)', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (radians)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This graph shows how the angular displacement of the pendulum changes over time under damping and periodic forcing. Expected Additional Plots: Phase portraits to visualize stability and chaos. Bifurcation diagrams to show changes in periodicity. Conclusion The forced damped pendulum is a rich model for exploring chaotic dynamics, resonance, and real-world oscillations . By analyzing its behavior, we gain insights into engineering, physics, and even biological rhythms .","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#introduction","text":"The forced damped pendulum is a fundamental system in physics and engineering that demonstrates a transition from simple harmonic motion to resonance and chaos due to the interplay of damping, restoring forces, and external periodic forcing. This study helps us understand complex real-world applications, including energy harvesting, vibration isolation, and mechanical resonance.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is described by the following differential equation : \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] where: \\(\u03b8\\) \u2192 Angular displacement (radians) \\(b\\) \u2192 Damping coefficient (controls energy loss) \\(g\\) \u2192 Gravitational acceleration \\(L\\) \u2192 Length of the pendulum \\(A\\) \u2192 Amplitude of the external driving force \\(\u03a9\\) \u2192 Frequency of the external force","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations , we approximate \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear equation , and its solution describes harmonic oscillations .","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"When the driving frequency \\(\u03a9\\) matches the system's natural frequency: $$ \\omega_0 = \\sqrt{\\frac{g}{L}} $$ resonance occurs, leading to maximum oscillations . At high amplitudes, the system can enter chaotic motion .","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#key-parameters-affecting-motion","text":"Damping coefficient \\(b\\) : Higher damping reduces oscillations and suppresses chaos. Driving force amplitude \\(A\\) : Large values introduce nonlinear behavior and chaos. Driving frequency \\(\u03a9\\) : Affects resonance and synchronization.","title":"Key Parameters Affecting Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"Low damping & weak forcing \u2192 Periodic oscillations (predictable motion). Moderate forcing \u2192 Resonance (large oscillations at specific frequencies). High forcing & nonlinearity \u2192 Chaos (unpredictable motion with extreme sensitivity to initial conditions).","title":"Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"","title":"3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#common-uses-of-forced-damped-pendulums","text":"Suspension Bridges \u2192 Studying oscillations in structures. Energy Harvesting \u2192 Using vibrations to generate electricity. Oscillating Circuits \u2192 Analogous to driven RLC circuits .","title":"Common Uses of Forced Damped Pendulums"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#real-world-example-a-playground-swing","text":"A swing acts as a forced damped pendulum: The child\u2019s motion adds an external periodic force . If pushing is in sync with the swing\u2019s natural frequency \u2192 Resonance occurs (higher amplitude). If air resistance & friction increase \u2192 Damping reduces motion . Random pushing at different times can lead to chaotic motion .","title":"Real-World Example: A Playground Swing"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computational-implementation","text":"We develop a Python simulation to: Numerically solve the differential equation . Visualize pendulum motion for different damping and forcing. Generate phase diagrams and Poincar\u00e9 sections to illustrate chaotic transitions.","title":"4. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-script","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.5 # Damping coefficient g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of the pendulum (m) A = 1.2 # Driving force amplitude omega_drive = 2.0 # Driving frequency # Initial conditions theta_0 = 0.2 # Initial angle (radians) omega_0 = 0.0 # Initial angular velocity # Time span t_span = (0, 20) # Simulate for 20 seconds t_eval = np.linspace(*t_span, 1000) # Solve the equation sol = solve_ivp(forced_damped_pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(b, g, L, A, omega_drive)) # Plot results plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], label='Theta (Angular Displacement)', color='b') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (radians)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This graph shows how the angular displacement of the pendulum changes over time under damping and periodic forcing.","title":"Python Script"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#expected-additional-plots","text":"Phase portraits to visualize stability and chaos. Bifurcation diagrams to show changes in periodicity.","title":"Expected Additional Plots:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum is a rich model for exploring chaotic dynamics, resonance, and real-world oscillations . By analyzing its behavior, we gain insights into engineering, physics, and even biological rhythms .","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Radius \"The harmony of the world is made manifest in the laws of nature.\" \u2013 Kepler What Are We Exploring? We aim to understand how a planet or satellite\u2019s orbital period (how long it takes to complete an orbit) is related to its distance from the central body . This brings us to Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\] Where: \\(T\\) = Orbital period \\(r\\) = Orbital radius The Physics Behind It We start from two fundamental physics principles: Newton\u2019s Law of Gravitation: $$ F = \\frac{G M m}{r^2} $$ Centripetal force needed to keep an object in circular motion: $$ F = \\frac{m v^2}{r} $$ Setting them equal, and working through the math (see full derivation in notebook), we arrive at: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] This shows that for circular orbits , the square of the orbital period is proportional to the cube of the radius. Real-World Example: The Moon & Earth By measuring: \\(T\\) (orbital period \u2248 27.3 days) \\(r\\) (distance from Earth to Moon \u2248 384,400 km) we can apply Kepler\u2019s Law to calculate Earth\u2019s mass \u2014 or vice versa , confirm these values based on known mass. Visual Verification We ran a Python simulation to compute and plot \\(T^2\\) and \\(r^3\\) values for circular orbits around Earth. Below is the graph showing this relationship: As expected, the relationship is linear , confirming Kepler's Third Law in action. Why Does This Matter? Helps design satellite orbits (e.g., GPS, Starlink) Enables planetary exploration by predicting orbital paths Essential for calculating masses of planets and stars What About Elliptical Orbits? Kepler\u2019s Law also applies to elliptical orbits , with a small change: \\[ T^2 \\propto a^3 \\] Where \\(a\\) is the semi-major axis of the ellipse. Summary We derived Kepler\u2019s Third Law from basic physics. We verified it through Python simulation. We explored how it's used in astronomy and satellite science.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-radius","text":"\"The harmony of the world is made manifest in the laws of nature.\" \u2013 Kepler","title":"Kepler's Third Law: Orbital Period and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#what-are-we-exploring","text":"We aim to understand how a planet or satellite\u2019s orbital period (how long it takes to complete an orbit) is related to its distance from the central body . This brings us to Kepler\u2019s Third Law : \\[ T^2 \\propto r^3 \\] Where: \\(T\\) = Orbital period \\(r\\) = Orbital radius","title":"What Are We Exploring?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-physics-behind-it","text":"We start from two fundamental physics principles: Newton\u2019s Law of Gravitation: $$ F = \\frac{G M m}{r^2} $$ Centripetal force needed to keep an object in circular motion: $$ F = \\frac{m v^2}{r} $$ Setting them equal, and working through the math (see full derivation in notebook), we arrive at: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] This shows that for circular orbits , the square of the orbital period is proportional to the cube of the radius.","title":"The Physics Behind It"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-example-the-moon-earth","text":"By measuring: \\(T\\) (orbital period \u2248 27.3 days) \\(r\\) (distance from Earth to Moon \u2248 384,400 km) we can apply Kepler\u2019s Law to calculate Earth\u2019s mass \u2014 or vice versa , confirm these values based on known mass.","title":"Real-World Example: The Moon &amp; Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visual-verification","text":"We ran a Python simulation to compute and plot \\(T^2\\) and \\(r^3\\) values for circular orbits around Earth. Below is the graph showing this relationship: As expected, the relationship is linear , confirming Kepler's Third Law in action.","title":"Visual Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#why-does-this-matter","text":"Helps design satellite orbits (e.g., GPS, Starlink) Enables planetary exploration by predicting orbital paths Essential for calculating masses of planets and stars","title":"Why Does This Matter?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#what-about-elliptical-orbits","text":"Kepler\u2019s Law also applies to elliptical orbits , with a small change: \\[ T^2 \\propto a^3 \\] Where \\(a\\) is the semi-major axis of the ellipse.","title":"What About Elliptical Orbits?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived Kepler\u2019s Third Law from basic physics. We verified it through Python simulation. We explored how it's used in astronomy and satellite science.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities \u201cThe Earth is the cradle of humanity, but one cannot remain in the cradle forever.\u201d \u2013 Konstantin Tsiolkovsky Overview Cosmic velocities define the speeds needed for different types of motion under a planet\u2019s gravitational pull. These thresholds are fundamental to space exploration , from placing satellites in orbit to launching probes into interstellar space. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) The minimum speed required to stay in a stable circular orbit just above a planet\u2019s surface. $$ v_1 = \\sqrt{\\frac{G M}{r}} $$ Second Cosmic Velocity (Escape Velocity) The minimum speed required to completely escape the gravitational field of a planet without further propulsion. $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} $$ Third Cosmic Velocity (Solar Escape Velocity) The speed needed to escape the gravitational pull of the Sun from Earth\u2019s surface. This includes Earth\u2019s orbital motion and the Sun\u2019s gravitational field. Approximate value: $$ v_3 \\approx 42.1 \\text{ km/s (from Earth)} $$ Parameters and Equations To compute these velocities, we use the following parameters: Planet Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.3895 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\) Visual Comparison of Velocities The following chart shows the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. For solar escape (v\u2083), only Earth is shown. Real-World Applications Mission Type Required Velocity Placing a satellite in orbit \\(v_1\\) Sending a spacecraft to the Moon or Mars \\(v_2\\) Voyager, New Horizons, Interstellar missions \\(v_3\\) Applying Cosmic Velocities A rocket launching from Earth must first reach orbital velocity (v\u2081) to stay in space. To break free from Earth\u2019s gravity, it must accelerate to escape velocity (v\u2082) . To leave the Solar System , like the Voyager missions , it must achieve the third cosmic velocity (v\u2083) . Conclusion First cosmic velocity lets you orbit. Second cosmic velocity lets you escape. Third cosmic velocity lets you leave the Solar System. These values are not just theoretical\u2014they define the thresholds every rocket must overcome in real missions.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"\u201cThe Earth is the cradle of humanity, but one cannot remain in the cradle forever.\u201d \u2013 Konstantin Tsiolkovsky","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#overview","text":"Cosmic velocities define the speeds needed for different types of motion under a planet\u2019s gravitational pull. These thresholds are fundamental to space exploration , from placing satellites in orbit to launching probes into interstellar space.","title":"Overview"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The minimum speed required to stay in a stable circular orbit just above a planet\u2019s surface. $$ v_1 = \\sqrt{\\frac{G M}{r}} $$","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The minimum speed required to completely escape the gravitational field of a planet without further propulsion. $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} $$","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-escape-velocity","text":"The speed needed to escape the gravitational pull of the Sun from Earth\u2019s surface. This includes Earth\u2019s orbital motion and the Sun\u2019s gravitational field. Approximate value: $$ v_3 \\approx 42.1 \\text{ km/s (from Earth)} $$","title":"Third Cosmic Velocity (Solar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-and-equations","text":"To compute these velocities, we use the following parameters: Planet Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.3895 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.9911 \\times 10^7\\)","title":"Parameters and Equations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visual-comparison-of-velocities","text":"The following chart shows the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. For solar escape (v\u2083), only Earth is shown.","title":"Visual Comparison of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#real-world-applications","text":"Mission Type Required Velocity Placing a satellite in orbit \\(v_1\\) Sending a spacecraft to the Moon or Mars \\(v_2\\) Voyager, New Horizons, Interstellar missions \\(v_3\\)","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#applying-cosmic-velocities","text":"A rocket launching from Earth must first reach orbital velocity (v\u2081) to stay in space. To break free from Earth\u2019s gravity, it must accelerate to escape velocity (v\u2082) . To leave the Solar System , like the Voyager missions , it must achieve the third cosmic velocity (v\u2083) .","title":"Applying Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"First cosmic velocity lets you orbit. Second cosmic velocity lets you escape. Third cosmic velocity lets you leave the Solar System. These values are not just theoretical\u2014they define the thresholds every rocket must overcome in real missions.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object (payload) is released from a rocket near Earth, it enters a new gravitational context depending on its velocity, position, and direction. This scenario helps us explore the principles of orbital mechanics , gravitational physics , and space mission dynamics . Theoretical Background Newton's Law of Gravitation The force acting on the payload due to Earth's gravity is: $$ \\vec{F} = -\\frac{G M m}{r^2} \\hat{r} $$ Where: - \\(G\\) is the gravitational constant \\(M\\) is Earth\u2019s mass \\(m\\) is the payload\u2019s mass \\(r\\) is the distance from Earth's center \\(\\hat{r}\\) is the unit vector pointing from the payload to the Earth\u2019s center This force produces an acceleration: $$ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} $$ Orbital Energy and Trajectory Types The total mechanical energy \\(E\\) of the payload determines the type of trajectory: - \\(E < 0\\) : Elliptical orbit (bound) \\(E = 0\\) : Parabolic trajectory (escape edge) \\(E > 0\\) : Hyperbolic trajectory (escape) Key Velocities Orbital velocity : \\( \\(v = \\sqrt{\\frac{G M}{r}}\\) \\) Escape velocity : \\( \\(v = \\sqrt{\\frac{2 G M}{r}}\\) \\) Simulation in Python Below is a Python implementation that simulates the motion of a payload released from low Earth orbit with various initial speeds. Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Gravitational acceleration function def gravity(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, vy, ax, ay] # Initial conditions for different velocities altitude = 300e3 # 300 km above Earth surface r0 = R_earth + altitude angles = [0, 30, 45, 60] # degrees # Choose initial speeds v_orbit = np.sqrt(G * M / r0) # orbital v_escape = np.sqrt(2 * G * M / r0) # escape velocities = [0.8 * v_orbit, v_orbit, 1.1 * v_orbit, v_escape * 1.05] # Time span t_span = (0, 7000) t_eval = np.linspace(*t_span, 1000) # Plot setup plt.figure(figsize=(8, 8)) for v0 in velocities: y0 = [r0, 0, 0, v0] # launch from (r0, 0) with velocity in y direction sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) plt.plot(sol.y[0] / 1e3, sol.y[1] / 1e3, label=f'v0 = {v0/1e3:.2f} km/s') # Earth circle = plt.Circle((0, 0), R_earth / 1e3, color='blue', alpha=0.3, label='Earth') plt.gca().add_artist(circle) plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Payload Trajectories from Low Earth Orbit') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Trajectory Types Observed Sub-orbital fall (if initial speed is too low) Circular/Elliptical orbit (if speed \u2248 orbital speed) Escape (if speed > escape velocity) Hyperbolic (if speed greatly exceeds escape velocity) Real-World Applications Satellite deployment : Requires precision in velocity to maintain orbit Reentry capsules : Released to descend back to Earth Interplanetary missions : Require escape trajectory from Earth and then Sun Conclusion By changing the initial speed and angle , the payload\u2019s trajectory dramatically shifts. Numerical simulations provide deep insights into how small changes affect mission success\u2014from stable orbits to deep space escape. This analysis and tool are fundamental in planning any real-world space deployment or return mission.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object (payload) is released from a rocket near Earth, it enters a new gravitational context depending on its velocity, position, and direction. This scenario helps us explore the principles of orbital mechanics , gravitational physics , and space mission dynamics .","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The force acting on the payload due to Earth's gravity is: $$ \\vec{F} = -\\frac{G M m}{r^2} \\hat{r} $$ Where: - \\(G\\) is the gravitational constant \\(M\\) is Earth\u2019s mass \\(m\\) is the payload\u2019s mass \\(r\\) is the distance from Earth's center \\(\\hat{r}\\) is the unit vector pointing from the payload to the Earth\u2019s center This force produces an acceleration: $$ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} $$","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-energy-and-trajectory-types","text":"The total mechanical energy \\(E\\) of the payload determines the type of trajectory: - \\(E < 0\\) : Elliptical orbit (bound) \\(E = 0\\) : Parabolic trajectory (escape edge) \\(E > 0\\) : Hyperbolic trajectory (escape)","title":"Orbital Energy and Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-velocities","text":"Orbital velocity : \\( \\(v = \\sqrt{\\frac{G M}{r}}\\) \\) Escape velocity : \\( \\(v = \\sqrt{\\frac{2 G M}{r}}\\) \\)","title":"Key Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-in-python","text":"Below is a Python implementation that simulates the motion of a payload released from low Earth orbit with various initial speeds.","title":"Simulation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Gravitational acceleration function def gravity(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, vy, ax, ay] # Initial conditions for different velocities altitude = 300e3 # 300 km above Earth surface r0 = R_earth + altitude angles = [0, 30, 45, 60] # degrees # Choose initial speeds v_orbit = np.sqrt(G * M / r0) # orbital v_escape = np.sqrt(2 * G * M / r0) # escape velocities = [0.8 * v_orbit, v_orbit, 1.1 * v_orbit, v_escape * 1.05] # Time span t_span = (0, 7000) t_eval = np.linspace(*t_span, 1000) # Plot setup plt.figure(figsize=(8, 8)) for v0 in velocities: y0 = [r0, 0, 0, v0] # launch from (r0, 0) with velocity in y direction sol = solve_ivp(gravity, t_span, y0, t_eval=t_eval, rtol=1e-8) plt.plot(sol.y[0] / 1e3, sol.y[1] / 1e3, label=f'v0 = {v0/1e3:.2f} km/s') # Earth circle = plt.Circle((0, 0), R_earth / 1e3, color='blue', alpha=0.3, label='Earth') plt.gca().add_artist(circle) plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Payload Trajectories from Low Earth Orbit') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types-observed","text":"Sub-orbital fall (if initial speed is too low) Circular/Elliptical orbit (if speed \u2248 orbital speed) Escape (if speed > escape velocity) Hyperbolic (if speed greatly exceeds escape velocity)","title":"Trajectory Types Observed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Satellite deployment : Requires precision in velocity to maintain orbit Reentry capsules : Released to descend back to Earth Interplanetary missions : Require escape trajectory from Earth and then Sun","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"By changing the initial speed and angle , the payload\u2019s trajectory dramatically shifts. Numerical simulations provide deep insights into how small changes affect mission success\u2014from stable orbits to deep space escape. This analysis and tool are fundamental in planning any real-world space deployment or return mission.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Introduction This report focuses on the interference of surface water waves originating from multiple coherent point sources. These sources are placed at the vertices of a regular polygon, ensuring symmetrical spacing and uniform conditions for wave propagation. The primary objective is to analyze how the superposition of such waves forms complex interference patterns, and to understand the role of geometrical arrangements and wave parameters in shaping these patterns. The simulation is developed in Python using numerical techniques and graphical visualization. By plotting the resultant displacement of the water surface, we can clearly distinguish between areas of constructive and destructive interference and study their symmetry. Geometrical Configuration of Sources import matplotlib.pyplot as plt import numpy as np n_sources = 4 radius = 2 angles = np.linspace(0, 2*np.pi, n_sources, endpoint=False) x_coords = radius * np.cos(angles) y_coords = radius * np.sin(angles) fig, ax = plt.subplots(figsize=(6,6)) ax.scatter(x_coords, y_coords, color='red', label='Sources') for i, (x, y) in enumerate(zip(x_coords, y_coords)): ax.text(x + 0.1, y + 0.1, f\"S{i+1}\", fontsize=12) circle = plt.Circle((0, 0), radius, color='blue', fill=False, linestyle='--', alpha=0.5) ax.add_patch(circle) ax.set_xlim(-3, 3) ax.set_ylim(-3, 3) ax.set_aspect('equal') ax.grid(True) ax.legend() plt.title('Wave Sources Positioned on a Square') plt.show() All sources are coherent and monochromatic (same wavelength, frequency, and amplitude). Waves propagate as circular wavefronts from each source. The water surface displacement is calculated using the principle of linear superposition. Simulation is conducted in 2D space on a uniform grid. Mathematical Background The displacement \\(u\\vec{r}\\) , t at position \\(\\vec{r}\\) and time \\(t\\) due to a single wave source at position \\(\\vec{r}_0\\) is given by: \\[u(\\vec{r}, t) = A \\sin(k|\\vec{r} - \\vec{r}_0| - \\omega t + \\phi)\\] Where: - \\(A\\) : Amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number, \\(\\lambda\\) is the wavelength \\(\\omega = 2\\pi f\\) : Angular frequency, \\(f\\) is the frequency \\(\\phi\\) : Initial phase \\(|\\vec{r} - \\vec{r}_0|\\) : Distance from the source to point \\(\\vec{r}\\) The total displacement from multiple sources is: \\[u_{total}(\\vec{r}, t) = \\sum_{i=1}^{N} A \\sin(k|\\vec{r} - \\vec{r}_i| - \\omega t + \\phi)\\] Where \\(N\\) is the number of sources. Implementation in Python Imports import numpy as np import matplotlib.pyplot as plt Parameters A = 1.0 # Amplitude wavelength = 2.0 # Wavelength (lambda) k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0.0 # Initial phase Simulation Grid x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) t = 0 # Time snapshot (can vary this for animation) Polygon Source Placement n_sources = 4 # Change to 3, 5, etc. for other polygons radius = 2.0 # Distance from center to each source angles = np.linspace(0, 2 * np.pi, n_sources, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] Superposition of Waves Z_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z = A * np.sin(k * r - omega * t + phi) Z_total += Z Visualization of Interference Pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Z_total, levels=200, cmap='RdBu') plt.colorbar(label='Displacement') plt.title(f'Interference Pattern from {n_sources}-Sided Polygon Configuration') plt.xlabel('x position') plt.ylabel('y position') plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.5) plt.show() Observations and Analysis The resulting interference pattern, derived from the superposition of waves emitted at regular polygon vertices, reveals several significant physical phenomena: Constructive Interference Constructive interference occurs at points where the wavefronts from multiple sources arrive in phase. This means the path length differences between sources correspond to integer multiples of the wavelength. In the visualization, these points manifest as high-displacement fringes. For a square configuration, these fringes exhibit square symmetry, with pronounced periodicity along diagonals and sides. Destructive Interference Destructive interference emerges where wavefronts arrive out of phase (typically by half a wavelength). This leads to cancellation of displacement, and such areas are represented by low or nearly zero values in the plot. These points often lie between the maxima and form nodal lines or regions, creating the characteristic ripple effects seen in the interference map. Symmetry of the Pattern The symmetry of the polygonal configuration plays a crucial role in shaping the pattern. A square arrangement yields a pattern with fourfold rotational symmetry and reflectional symmetry along its diagonals and axes. If the number of sources changes (e.g., using a triangle or pentagon), the symmetry and spacing of the interference fringes would also change correspondingly. Fringe Spacing and Wavelength Relationship The density of interference fringes is inversely proportional to the wavelength. A shorter wavelength results in more closely spaced fringes, increasing the resolution and complexity of the pattern. In this simulation, the chosen wavelength balances clarity with computational feasibility. Interpretation of the Color Map The color map in the visualization represents instantaneous displacement of the water surface. Red and blue regions denote opposite displacement polarities (peaks and troughs), while intermediate colors indicate zero-crossings or regions of destructive interference. The clear, periodic alternation between high and low displacement illustrates the coherent and stable nature of the wave sources. Influence of Source Radius The radius of the polygon (i.e., the distance from the origin to each source) determines the overall scale of the interference structure. A larger radius spreads the sources farther apart, potentially increasing the central region\u2019s complexity. Conversely, a smaller radius condenses the interference features near the center. Overall, the analysis shows that the resulting interference pattern is a rich function of geometry, wavelength, and wave coherence. These findings are fundamental in fields like optics, acoustics, and fluid dynamics. Animate the wave pattern over time by varying t Use other polygons (triangle, pentagon, hexagon) and compare their patterns Change phase differences between sources for more complex interactions Add damping or nonlinear effects for more realism Conclusion This simulation effectively visualizes how waves from multiple sources interact on a water surface. By leveraging symmetry and wave superposition, we gain a clearer understanding of the principles of interference and the beauty of wave physics in two dimensions.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"This report focuses on the interference of surface water waves originating from multiple coherent point sources. These sources are placed at the vertices of a regular polygon, ensuring symmetrical spacing and uniform conditions for wave propagation. The primary objective is to analyze how the superposition of such waves forms complex interference patterns, and to understand the role of geometrical arrangements and wave parameters in shaping these patterns. The simulation is developed in Python using numerical techniques and graphical visualization. By plotting the resultant displacement of the water surface, we can clearly distinguish between areas of constructive and destructive interference and study their symmetry.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#geometrical-configuration-of-sources","text":"import matplotlib.pyplot as plt import numpy as np n_sources = 4 radius = 2 angles = np.linspace(0, 2*np.pi, n_sources, endpoint=False) x_coords = radius * np.cos(angles) y_coords = radius * np.sin(angles) fig, ax = plt.subplots(figsize=(6,6)) ax.scatter(x_coords, y_coords, color='red', label='Sources') for i, (x, y) in enumerate(zip(x_coords, y_coords)): ax.text(x + 0.1, y + 0.1, f\"S{i+1}\", fontsize=12) circle = plt.Circle((0, 0), radius, color='blue', fill=False, linestyle='--', alpha=0.5) ax.add_patch(circle) ax.set_xlim(-3, 3) ax.set_ylim(-3, 3) ax.set_aspect('equal') ax.grid(True) ax.legend() plt.title('Wave Sources Positioned on a Square') plt.show() All sources are coherent and monochromatic (same wavelength, frequency, and amplitude). Waves propagate as circular wavefronts from each source. The water surface displacement is calculated using the principle of linear superposition. Simulation is conducted in 2D space on a uniform grid.","title":"Geometrical Configuration of Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-background","text":"The displacement \\(u\\vec{r}\\) , t at position \\(\\vec{r}\\) and time \\(t\\) due to a single wave source at position \\(\\vec{r}_0\\) is given by: \\[u(\\vec{r}, t) = A \\sin(k|\\vec{r} - \\vec{r}_0| - \\omega t + \\phi)\\] Where: - \\(A\\) : Amplitude of the wave \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number, \\(\\lambda\\) is the wavelength \\(\\omega = 2\\pi f\\) : Angular frequency, \\(f\\) is the frequency \\(\\phi\\) : Initial phase \\(|\\vec{r} - \\vec{r}_0|\\) : Distance from the source to point \\(\\vec{r}\\) The total displacement from multiple sources is: \\[u_{total}(\\vec{r}, t) = \\sum_{i=1}^{N} A \\sin(k|\\vec{r} - \\vec{r}_i| - \\omega t + \\phi)\\] Where \\(N\\) is the number of sources.","title":"Mathematical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#implementation-in-python","text":"","title":"Implementation in Python"},{"location":"1%20Physics/3%20Waves/Problem_1/#imports","text":"import numpy as np import matplotlib.pyplot as plt","title":"Imports"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"A = 1.0 # Amplitude wavelength = 2.0 # Wavelength (lambda) k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0.0 # Initial phase","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-grid","text":"x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) t = 0 # Time snapshot (can vary this for animation)","title":"Simulation Grid"},{"location":"1%20Physics/3%20Waves/Problem_1/#polygon-source-placement","text":"n_sources = 4 # Change to 3, 5, etc. for other polygons radius = 2.0 # Distance from center to each source angles = np.linspace(0, 2 * np.pi, n_sources, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles]","title":"Polygon Source Placement"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"Z_total = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z = A * np.sin(k * r - omega * t + phi) Z_total += Z","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization-of-interference-pattern","text":"plt.figure(figsize=(10, 8)) plt.contourf(X, Y, Z_total, levels=200, cmap='RdBu') plt.colorbar(label='Displacement') plt.title(f'Interference Pattern from {n_sources}-Sided Polygon Configuration') plt.xlabel('x position') plt.ylabel('y position') plt.axis('equal') plt.grid(True, linestyle='--', alpha=0.5) plt.show()","title":"Visualization of Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations-and-analysis","text":"The resulting interference pattern, derived from the superposition of waves emitted at regular polygon vertices, reveals several significant physical phenomena:","title":"Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Constructive interference occurs at points where the wavefronts from multiple sources arrive in phase. This means the path length differences between sources correspond to integer multiples of the wavelength. In the visualization, these points manifest as high-displacement fringes. For a square configuration, these fringes exhibit square symmetry, with pronounced periodicity along diagonals and sides.","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Destructive interference emerges where wavefronts arrive out of phase (typically by half a wavelength). This leads to cancellation of displacement, and such areas are represented by low or nearly zero values in the plot. These points often lie between the maxima and form nodal lines or regions, creating the characteristic ripple effects seen in the interference map.","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-of-the-pattern","text":"The symmetry of the polygonal configuration plays a crucial role in shaping the pattern. A square arrangement yields a pattern with fourfold rotational symmetry and reflectional symmetry along its diagonals and axes. If the number of sources changes (e.g., using a triangle or pentagon), the symmetry and spacing of the interference fringes would also change correspondingly.","title":"Symmetry of the Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#fringe-spacing-and-wavelength-relationship","text":"The density of interference fringes is inversely proportional to the wavelength. A shorter wavelength results in more closely spaced fringes, increasing the resolution and complexity of the pattern. In this simulation, the chosen wavelength balances clarity with computational feasibility.","title":"Fringe Spacing and Wavelength Relationship"},{"location":"1%20Physics/3%20Waves/Problem_1/#interpretation-of-the-color-map","text":"The color map in the visualization represents instantaneous displacement of the water surface. Red and blue regions denote opposite displacement polarities (peaks and troughs), while intermediate colors indicate zero-crossings or regions of destructive interference. The clear, periodic alternation between high and low displacement illustrates the coherent and stable nature of the wave sources.","title":"Interpretation of the Color Map"},{"location":"1%20Physics/3%20Waves/Problem_1/#influence-of-source-radius","text":"The radius of the polygon (i.e., the distance from the origin to each source) determines the overall scale of the interference structure. A larger radius spreads the sources farther apart, potentially increasing the central region\u2019s complexity. Conversely, a smaller radius condenses the interference features near the center. Overall, the analysis shows that the resulting interference pattern is a rich function of geometry, wavelength, and wave coherence. These findings are fundamental in fields like optics, acoustics, and fluid dynamics. Animate the wave pattern over time by varying t Use other polygons (triangle, pentagon, hexagon) and compare their patterns Change phase differences between sources for more complex interactions Add damping or nonlinear effects for more realism","title":"Influence of Source Radius"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation effectively visualizes how waves from multiple sources interact on a water surface. By leveraging symmetry and wave superposition, we gain a clearer understanding of the principles of interference and the beauty of wave physics in two dimensions.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Lorentz Force Simulation: Motion of Charged Particles in Electric and Magnetic Fields Introduction The Lorentz force is the fundamental expression governing how charged particles move under the influence of electric and magnetic fields. It is given by: \\[\\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B})\\] Where: \\(q\\) is the charge of the particle \\(\\vec{E}\\) is the electric field vector \\(\\vec{B}\\) is the magnetic field vector \\(\\vec{v}\\) is the velocity vector of the particle This simulation demonstrates how particle motion is affected in different field configurations using numerical integration methods. Applications of the Lorentz Force Cyclotrons and Synchrotrons : Particle accelerators use magnetic fields to bend and focus beams of charged particles. Mass Spectrometry : Ions are separated based on their mass-to-charge ratio using magnetic and electric fields. Plasma Confinement : Magnetic fields are used to trap and control high-temperature plasmas in fusion devices (e.g., tokamaks). Electric fields accelerate charged particles, while magnetic fields bend their paths, causing circular or helical motion depending on the velocity vector. Complete Python Implementation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Physical constants q = 1.6e-19 # Charge (Coulombs) m = 1.67e-27 # Mass (kg) - using proton for better numerical stability # Mass (kg) # Choose one of the following cases: # Case 1: Uniform magnetic field only E = np.array([0.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) # Case 2: Crossed electric and magnetic fields (E \u22a5 B) # E = np.array([0.0, 100.0, 0.0]) # B = np.array([0.0, 0.0, 1.0]) # Case 3: Parallel E and B fields # E = np.array([0.0, 0.0, 100.0]) # B = np.array([0.0, 0.0, 1.0]) # Case 4: Only electric field (electric field acceleration) # E = np.array([100.0, 0.0, 0.0]) # B = np.array([0.0, 0.0, 0.0]) # Initial velocity and position v0 = np.array([1e5, 0.0, 0.0]) # Velocity in m/s r0 = np.array([0.0, 0.0, 0.0]) # Start at origin dt = 1e-10 steps = 3000 # Lorentz force equation def lorentz_force(q, E, B, v): return q * (E + np.cross(v, B)) # Motion simulation using Euler method def simulate_motion(q, m, E, B, r0, v0, dt, steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, steps): F = lorentz_force(q, E, B, v[i-1]) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r, v # Run the simulation r, v = simulate_motion(q, m, E, B, r0, v0, dt, steps) # Combined 2D Trajectories in One Plot # Define field configurations to test (E, B, label, color) cases = [ (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'Magnetic Field Only', 'blue'), (np.array([0.0, 100.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'E \u22a5 B Drift', 'green'), (np.array([0.0, 0.0, 100.0]), np.array([0.0, 0.0, 1.0]), 'E \u2016 B Fields', 'orange'), (np.array([100.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]), 'Electric Field Only', 'red'), (np.array([50.0, 50.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'Oblique E Field', 'purple'), (np.array([0.0, 0.0, 0.0]), np.array([1.0, 1.0, 1.0]), 'Diagonal B Field', 'brown') ] plt.figure(figsize=(10, 8)) for E_test, B_test, label, color in cases: r_case, _ = simulate_motion(q, m, E_test, B_test, r0, v0, dt, steps) plt.plot(r_case[:, 0], r_case[:, 1], label=label, color=color) plt.xlabel('X (m)') plt.ylabel('Y (m)') plt.title('Combined Trajectories in XY Plane') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Analysis The motion of a charged particle under the influence of electric and magnetic fields can vary significantly depending on the field configuration and the particle's initial velocity. This section breaks down key physical interpretations of the simulated motion, with accompanying visual examples to aid comprehension. 1. Uniform Magnetic Field (E = 0, B \u2260 0) In this configuration, the particle experiences a centripetal Lorentz force perpendicular to both its velocity and the magnetic field. If the initial velocity is perpendicular to the magnetic field, the result is circular motion . If the initial velocity has components both perpendicular and parallel to the field, the particle follows a helical path . plt.figure(figsize=(6,6)) plt.plot(r[:,0], r[:,1]) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Top View: Circular/Helical Motion in Uniform Magnetic Field') plt.axis('equal') plt.grid(True) plt.show() 2. Crossed Electric and Magnetic Fields (E \u22a5 B) When both E and B fields are present and perpendicular to each other, the charged particle undergoes a drift motion . The net motion combines the cyclotron motion with a linear drift in the direction of E \u00d7 B. This is known as the E \u00d7 B drift . Drift velocity: v_d = (E \u00d7 B) / B\u00b2 Simulation parameters for \\(E \u00d7 B\\) drift: E = np.array([0, 1e3, 0]) B = np.array([0, 0, 1]) Expected result: a helical trajectory drifting in the x-direction. 3. Larmor Radius (Cyclotron Radius) The Larmor radius, or gyroradius, defines the radius of circular motion in a magnetic field: \\[r_L = (m * v_perp) / (q * B)\\] It depends on the particle\u2019s mass, charge, magnetic field strength, and the perpendicular velocity component. A larger mass or velocity leads to a wider spiral. 4. Energy Conservation In a uniform magnetic field, the force is always perpendicular to the velocity, meaning the magnetic force does no work. Therefore, the kinetic energy of the particle remains constant throughout the motion. 5. Practical Example: Cyclotron A cyclotron accelerates particles using a combination of electric fields (for acceleration) and magnetic fields (to bend the path into circles). The simulation mimics the forces acting on particles in such devices, illustrating circular or helical motion\u2014fundamental to understanding particle dynamics in accelerators.","title":"Lorentz Force Simulation: Motion of Charged Particles in Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation-motion-of-charged-particles-in-electric-and-magnetic-fields","text":"","title":"Lorentz Force Simulation: Motion of Charged Particles in Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force is the fundamental expression governing how charged particles move under the influence of electric and magnetic fields. It is given by: \\[\\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B})\\] Where: \\(q\\) is the charge of the particle \\(\\vec{E}\\) is the electric field vector \\(\\vec{B}\\) is the magnetic field vector \\(\\vec{v}\\) is the velocity vector of the particle This simulation demonstrates how particle motion is affected in different field configurations using numerical integration methods.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"Cyclotrons and Synchrotrons : Particle accelerators use magnetic fields to bend and focus beams of charged particles. Mass Spectrometry : Ions are separated based on their mass-to-charge ratio using magnetic and electric fields. Plasma Confinement : Magnetic fields are used to trap and control high-temperature plasmas in fusion devices (e.g., tokamaks). Electric fields accelerate charged particles, while magnetic fields bend their paths, causing circular or helical motion depending on the velocity vector.","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#complete-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Physical constants q = 1.6e-19 # Charge (Coulombs) m = 1.67e-27 # Mass (kg) - using proton for better numerical stability # Mass (kg) # Choose one of the following cases: # Case 1: Uniform magnetic field only E = np.array([0.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) # Case 2: Crossed electric and magnetic fields (E \u22a5 B) # E = np.array([0.0, 100.0, 0.0]) # B = np.array([0.0, 0.0, 1.0]) # Case 3: Parallel E and B fields # E = np.array([0.0, 0.0, 100.0]) # B = np.array([0.0, 0.0, 1.0]) # Case 4: Only electric field (electric field acceleration) # E = np.array([100.0, 0.0, 0.0]) # B = np.array([0.0, 0.0, 0.0]) # Initial velocity and position v0 = np.array([1e5, 0.0, 0.0]) # Velocity in m/s r0 = np.array([0.0, 0.0, 0.0]) # Start at origin dt = 1e-10 steps = 3000 # Lorentz force equation def lorentz_force(q, E, B, v): return q * (E + np.cross(v, B)) # Motion simulation using Euler method def simulate_motion(q, m, E, B, r0, v0, dt, steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, steps): F = lorentz_force(q, E, B, v[i-1]) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r, v # Run the simulation r, v = simulate_motion(q, m, E, B, r0, v0, dt, steps) # Combined 2D Trajectories in One Plot # Define field configurations to test (E, B, label, color) cases = [ (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'Magnetic Field Only', 'blue'), (np.array([0.0, 100.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'E \u22a5 B Drift', 'green'), (np.array([0.0, 0.0, 100.0]), np.array([0.0, 0.0, 1.0]), 'E \u2016 B Fields', 'orange'), (np.array([100.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]), 'Electric Field Only', 'red'), (np.array([50.0, 50.0, 0.0]), np.array([0.0, 0.0, 1.0]), 'Oblique E Field', 'purple'), (np.array([0.0, 0.0, 0.0]), np.array([1.0, 1.0, 1.0]), 'Diagonal B Field', 'brown') ] plt.figure(figsize=(10, 8)) for E_test, B_test, label, color in cases: r_case, _ = simulate_motion(q, m, E_test, B_test, r0, v0, dt, steps) plt.plot(r_case[:, 0], r_case[:, 1], label=label, color=color) plt.xlabel('X (m)') plt.ylabel('Y (m)') plt.title('Combined Trajectories in XY Plane') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Complete Python Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#analysis","text":"The motion of a charged particle under the influence of electric and magnetic fields can vary significantly depending on the field configuration and the particle's initial velocity. This section breaks down key physical interpretations of the simulated motion, with accompanying visual examples to aid comprehension.","title":"Analysis"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-uniform-magnetic-field-e-0-b-0","text":"In this configuration, the particle experiences a centripetal Lorentz force perpendicular to both its velocity and the magnetic field. If the initial velocity is perpendicular to the magnetic field, the result is circular motion . If the initial velocity has components both perpendicular and parallel to the field, the particle follows a helical path . plt.figure(figsize=(6,6)) plt.plot(r[:,0], r[:,1]) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Top View: Circular/Helical Motion in Uniform Magnetic Field') plt.axis('equal') plt.grid(True) plt.show()","title":"1. Uniform Magnetic Field (E = 0, B \u2260 0)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-crossed-electric-and-magnetic-fields-e-b","text":"When both E and B fields are present and perpendicular to each other, the charged particle undergoes a drift motion . The net motion combines the cyclotron motion with a linear drift in the direction of E \u00d7 B. This is known as the E \u00d7 B drift . Drift velocity: v_d = (E \u00d7 B) / B\u00b2 Simulation parameters for \\(E \u00d7 B\\) drift: E = np.array([0, 1e3, 0]) B = np.array([0, 0, 1]) Expected result: a helical trajectory drifting in the x-direction.","title":"2. Crossed Electric and Magnetic Fields (E \u22a5 B)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-larmor-radius-cyclotron-radius","text":"The Larmor radius, or gyroradius, defines the radius of circular motion in a magnetic field: \\[r_L = (m * v_perp) / (q * B)\\] It depends on the particle\u2019s mass, charge, magnetic field strength, and the perpendicular velocity component. A larger mass or velocity leads to a wider spiral.","title":"3. Larmor Radius (Cyclotron Radius)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-energy-conservation","text":"In a uniform magnetic field, the force is always perpendicular to the velocity, meaning the magnetic force does no work. Therefore, the kinetic energy of the particle remains constant throughout the motion.","title":"4. Energy Conservation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-practical-example-cyclotron","text":"A cyclotron accelerates particles using a combination of electric fields (for acceleration) and magnetic fields (to bend the path into circles). The simulation mimics the forces acting on particles in such devices, illustrating circular or helical motion\u2014fundamental to understanding particle dynamics in accelerators.","title":"5. Practical Example: Cyclotron"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Introduction Determining the equivalent resistance between two points in a circuit is essential for understanding current flow and power distribution. While traditional series-parallel simplifications work for small circuits, complex or nested resistor networks are better handled using graph theory. By modeling the circuit as a graph: Nodes represent electrical junctions. Edges represent resistors with weights equal to their resistance. Problem Setup Graph Representation of a Circuit Each junction in the circuit becomes a node. Each resistor becomes a weighted edge. The goal is to reduce the graph until only one edge remains between the source and target nodes. Pseudocode and Algorithm Description Series Reduction Rule If a node has exactly two neighbors (degree 2) and is not the source/target: Replace it with a direct connection between its neighbors. Combine resistances by addition. Parallel Reduction Rule If there are multiple edges between the same two nodes: Combine resistances using the formula: \\( \\(R_{eq} = ( \\sum_{i} \\frac{1}{R_i})^{-1}\\) \\) Pseudocode FUNCTION simplify_circuit(graph): WHILE graph is not fully reduced: FOR each node: IF degree == 2 and not terminal: replace with series resistor FOR node pairs with multiple edges: replace with single parallel resistor RETURN resistance between source and target Python Implementation Imports and Utilities import networkx as nx import matplotlib.pyplot as plt def combine_series(R1, R2): return R1 + R2 def combine_parallel(R1, R2): return 1 / (1 / R1 + 1 / R2) Visualization Function def draw_graph(G, title): pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=600) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(title) plt.show() Simplification Algorithm def simplify_circuit(G, source, target): step = 1 draw_graph(G, f\"Step {step}: Initial Circuit\") step += 1 changed = True while changed: changed = False for node in list(G.nodes): if node not in [source, target] and G.degree(node) == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and not G.has_edge(neighbors[0], neighbors[1]): r1 = G[neighbors[0]][node]['resistance'] r2 = G[neighbors[1]][node]['resistance'] combined = combine_series(r1, r2) G.add_edge(neighbors[0], neighbors[1], resistance=combined) G.remove_node(node) changed = True draw_graph(G, f\"Step {step}: After series simplification at {node}\") step += 1 break edge_counts = {} for u, v in list(G.edges): key = tuple(sorted([u, v])) edge_counts.setdefault(key, []).append(G[u][v]['resistance']) for (u, v), resistances in edge_counts.items(): if len(resistances) > 1: req = resistances[0] for r in resistances[1:]: req = combine_parallel(req, r) G.remove_edges_from([(u, v)] * len(resistances)) G.add_edge(u, v, resistance=req) changed = True draw_graph(G, f\"Step {step}: After parallel simplification between {u}-{v}\") step += 1 break return G Test Circuit Example G = nx.Graph() G.add_edge('A', 'B', resistance=10) G.add_edge('B', 'C', resistance=20) G.add_edge('A', 'C', resistance=30) simplified = simplify_circuit(G, 'A', 'C') print(\"Final Equivalent Resistance between A and C:\", simplified['A']['C']['resistance']) Analysis and Use Cases Works well for resistive-only circuits. Scales better than manual methods for medium-complexity problems. Can be adapted for educational circuit solvers, PCB validation tools, and simulation engines.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Determining the equivalent resistance between two points in a circuit is essential for understanding current flow and power distribution. While traditional series-parallel simplifications work for small circuits, complex or nested resistor networks are better handled using graph theory. By modeling the circuit as a graph: Nodes represent electrical junctions. Edges represent resistors with weights equal to their resistance.","title":"Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-setup","text":"","title":"Problem Setup"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation-of-a-circuit","text":"Each junction in the circuit becomes a node. Each resistor becomes a weighted edge. The goal is to reduce the graph until only one edge remains between the source and target nodes.","title":"Graph Representation of a Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode-and-algorithm-description","text":"","title":"Pseudocode and Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-reduction-rule","text":"If a node has exactly two neighbors (degree 2) and is not the source/target: Replace it with a direct connection between its neighbors. Combine resistances by addition.","title":"Series Reduction Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-reduction-rule","text":"If there are multiple edges between the same two nodes: Combine resistances using the formula: \\( \\(R_{eq} = ( \\sum_{i} \\frac{1}{R_i})^{-1}\\) \\)","title":"Parallel Reduction Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"FUNCTION simplify_circuit(graph): WHILE graph is not fully reduced: FOR each node: IF degree == 2 and not terminal: replace with series resistor FOR node pairs with multiple edges: replace with single parallel resistor RETURN resistance between source and target","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#imports-and-utilities","text":"import networkx as nx import matplotlib.pyplot as plt def combine_series(R1, R2): return R1 + R2 def combine_parallel(R1, R2): return 1 / (1 / R1 + 1 / R2)","title":"Imports and Utilities"},{"location":"1%20Physics/5%20Circuits/Problem_1/#visualization-function","text":"def draw_graph(G, title): pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=600) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(title) plt.show()","title":"Visualization Function"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simplification-algorithm","text":"def simplify_circuit(G, source, target): step = 1 draw_graph(G, f\"Step {step}: Initial Circuit\") step += 1 changed = True while changed: changed = False for node in list(G.nodes): if node not in [source, target] and G.degree(node) == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and not G.has_edge(neighbors[0], neighbors[1]): r1 = G[neighbors[0]][node]['resistance'] r2 = G[neighbors[1]][node]['resistance'] combined = combine_series(r1, r2) G.add_edge(neighbors[0], neighbors[1], resistance=combined) G.remove_node(node) changed = True draw_graph(G, f\"Step {step}: After series simplification at {node}\") step += 1 break edge_counts = {} for u, v in list(G.edges): key = tuple(sorted([u, v])) edge_counts.setdefault(key, []).append(G[u][v]['resistance']) for (u, v), resistances in edge_counts.items(): if len(resistances) > 1: req = resistances[0] for r in resistances[1:]: req = combine_parallel(req, r) G.remove_edges_from([(u, v)] * len(resistances)) G.add_edge(u, v, resistance=req) changed = True draw_graph(G, f\"Step {step}: After parallel simplification between {u}-{v}\") step += 1 break return G","title":"Simplification Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#test-circuit-example","text":"G = nx.Graph() G.add_edge('A', 'B', resistance=10) G.add_edge('B', 'C', resistance=20) G.add_edge('A', 'C', resistance=30) simplified = simplify_circuit(G, 'A', 'C') print(\"Final Equivalent Resistance between A and C:\", simplified['A']['C']['resistance'])","title":"Test Circuit Example"},{"location":"1%20Physics/5%20Circuits/Problem_1/#analysis-and-use-cases","text":"Works well for resistive-only circuits. Scales better than manual methods for medium-complexity problems. Can be adapted for educational circuit solvers, PCB validation tools, and simulation engines.","title":"Analysis and Use Cases"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is a foundational principle in probability and statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases, regardless of the original population distribution \u2014provided the samples are independent and identically distributed. This property is essential for statistical inference and underpins many techniques in hypothesis testing, confidence intervals, and quality control. In this project, we explore the CLT through hands-on simulations using Python. Mathematical Expression of the CLT Let \\(X_1, X_2, \\ldots, X_n\\) be a random sample of size \\(n\\) drawn from a population with: Mean \\(\\mu\\) Standard deviation \\(\\sigma\\) Then the sampling distribution of the sample mean \\(\\bar{X}\\) approaches a normal distribution as \\(n \\to \\infty\\) : \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\xrightarrow{d} \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] This means: The mean of the sampling distribution is \\(\\mu\\) The variance is \\(\\frac{\\sigma^2}{n}\\) The standard deviation (called the standard error) is \\(\\frac{\\sigma}{\\sqrt{n}}\\) Simulation Setup We investigate the CLT using the following population distributions: Uniform Distribution : All values within a range are equally likely. Exponential Distribution : A skewed distribution modeling time between events. Binomial Distribution : Discrete distribution representing success/failure outcomes. Libraries and Configuration import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Plot styling sns.set(style=\"whitegrid\") np.random.seed(42) # Configuration population_size = 100_000 sample_sizes = [5, 10, 30, 50] num_samples = 1000 Uniform Distribution Population Overview # Generate uniform distribution uniform_population = np.random.uniform(low=0, high=10, size=population_size) # Plot population sns.histplot(uniform_population, bins=50, kde=True) plt.title(\"Uniform Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show() Sampling Distributions for n in sample_sizes: means = [np.mean(np.random.choice(uniform_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Uniform, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show() Exponential Distribution Population Overview # Generate exponential distribution exponential_population = np.random.exponential(scale=1.0, size=population_size) sns.histplot(exponential_population, bins=50, kde=True) plt.title(\"Exponential Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show() Sampling Distributions for n in sample_sizes: means = [np.mean(np.random.choice(exponential_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Exponential, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show() Binomial Distribution Population Overview # Generate binomial distribution binomial_population = np.random.binomial(n=10, p=0.5, size=population_size) sns.histplot(binomial_population, bins=11) plt.title(\"Binomial Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show() Sampling Distributions for n in sample_sizes: means = [np.mean(np.random.choice(binomial_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Binomial, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show() Observations As the sample size increases , the sampling distribution of the mean approaches a normal shape . This convergence occurs regardless of the population distribution : For skewed distributions like exponential, larger sample sizes are needed. For symmetric distributions like uniform or binomial, convergence is faster. The spread (standard deviation) of the sampling distribution decreases with larger samples . Real-World Applications The CLT is used in: Estimating population parameters when the population distribution is unknown. Quality control in industrial settings using sample-based inspections. Finance for modeling average returns and risks. Scientific research where sample statistics are used for inference. Tools and Technologies NumPy : Random data generation and statistical operations Matplotlib & Seaborn : Plotting and visualization Conclusion Through these simulations, we observed the Central Limit Theorem in action: no matter the shape of the original distribution, the distribution of the sample mean becomes approximately normal as the sample size increases. This powerful result explains the ubiquity of the normal distribution in statistics and confirms why the CLT is a cornerstone of inferential techniques.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a foundational principle in probability and statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases, regardless of the original population distribution \u2014provided the samples are independent and identically distributed. This property is essential for statistical inference and underpins many techniques in hypothesis testing, confidence intervals, and quality control. In this project, we explore the CLT through hands-on simulations using Python.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#mathematical-expression-of-the-clt","text":"Let \\(X_1, X_2, \\ldots, X_n\\) be a random sample of size \\(n\\) drawn from a population with: Mean \\(\\mu\\) Standard deviation \\(\\sigma\\) Then the sampling distribution of the sample mean \\(\\bar{X}\\) approaches a normal distribution as \\(n \\to \\infty\\) : \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\xrightarrow{d} \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] This means: The mean of the sampling distribution is \\(\\mu\\) The variance is \\(\\frac{\\sigma^2}{n}\\) The standard deviation (called the standard error) is \\(\\frac{\\sigma}{\\sqrt{n}}\\)","title":"Mathematical Expression of the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-setup","text":"We investigate the CLT using the following population distributions: Uniform Distribution : All values within a range are equally likely. Exponential Distribution : A skewed distribution modeling time between events. Binomial Distribution : Discrete distribution representing success/failure outcomes.","title":"Simulation Setup"},{"location":"1%20Physics/6%20Statistics/Problem_1/#libraries-and-configuration","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Plot styling sns.set(style=\"whitegrid\") np.random.seed(42) # Configuration population_size = 100_000 sample_sizes = [5, 10, 30, 50] num_samples = 1000","title":"Libraries and Configuration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#uniform-distribution","text":"","title":"Uniform Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-overview","text":"# Generate uniform distribution uniform_population = np.random.uniform(low=0, high=10, size=population_size) # Plot population sns.histplot(uniform_population, bins=50, kde=True) plt.title(\"Uniform Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show()","title":"Population Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-distributions","text":"for n in sample_sizes: means = [np.mean(np.random.choice(uniform_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Uniform, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show()","title":"Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exponential-distribution","text":"","title":"Exponential Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-overview_1","text":"# Generate exponential distribution exponential_population = np.random.exponential(scale=1.0, size=population_size) sns.histplot(exponential_population, bins=50, kde=True) plt.title(\"Exponential Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show()","title":"Population Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-distributions_1","text":"for n in sample_sizes: means = [np.mean(np.random.choice(exponential_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Exponential, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show()","title":"Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#binomial-distribution","text":"","title":"Binomial Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-overview_2","text":"# Generate binomial distribution binomial_population = np.random.binomial(n=10, p=0.5, size=population_size) sns.histplot(binomial_population, bins=11) plt.title(\"Binomial Population Distribution\") plt.xlabel(\"Value\") plt.ylabel(\"Frequency\") plt.show()","title":"Population Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-distributions_2","text":"for n in sample_sizes: means = [np.mean(np.random.choice(binomial_population, size=n)) for _ in range(num_samples)] sns.histplot(means, bins=30, kde=True) plt.title(f\"Sample Means (Binomial, n={n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.show()","title":"Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations","text":"As the sample size increases , the sampling distribution of the mean approaches a normal shape . This convergence occurs regardless of the population distribution : For skewed distributions like exponential, larger sample sizes are needed. For symmetric distributions like uniform or binomial, convergence is faster. The spread (standard deviation) of the sampling distribution decreases with larger samples .","title":"Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-applications","text":"The CLT is used in: Estimating population parameters when the population distribution is unknown. Quality control in industrial settings using sample-based inspections. Finance for modeling average returns and risks. Scientific research where sample statistics are used for inference.","title":"Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#tools-and-technologies","text":"NumPy : Random data generation and statistical operations Matplotlib & Seaborn : Plotting and visualization","title":"Tools and Technologies"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"Through these simulations, we observed the Central Limit Theorem in action: no matter the shape of the original distribution, the distribution of the sample mean becomes approximately normal as the sample size increases. This powerful result explains the ubiquity of the normal distribution in statistics and confirms why the CLT is a cornerstone of inferential techniques.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}